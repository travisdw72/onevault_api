{
  "contamination_check": {
    "all_schemas": [
      [
        "ai_monitoring",
        "postgres",
        "OTHER"
      ],
      [
        "archive",
        "postgres",
        "OTHER"
      ],
      [
        "compliance",
        "postgres",
        "OTHER"
      ],
      [
        "debug",
        "postgres",
        "OTHER"
      ],
      [
        "infomart",
        "postgres",
        "OTHER"
      ],
      [
        "metadata",
        "postgres",
        "OTHER"
      ],
      [
        "pg_toast_temp_18",
        "postgres",
        "OTHER"
      ],
      [
        "pg_toast_temp_83",
        "postgres",
        "OTHER"
      ],
      [
        "public",
        "pg_database_owner",
        "OTHER"
      ],
      [
        "validation",
        "postgres",
        "OTHER"
      ],
      [
        "information_schema",
        "postgres",
        "SYSTEM"
      ],
      [
        "pg_catalog",
        "postgres",
        "SYSTEM"
      ],
      [
        "pg_toast",
        "postgres",
        "SYSTEM"
      ],
      [
        "api",
        "postgres",
        "TEMPLATE CORE"
      ],
      [
        "audit",
        "postgres",
        "TEMPLATE CORE"
      ],
      [
        "auth",
        "postgres",
        "TEMPLATE CORE"
      ],
      [
        "business",
        "postgres",
        "TEMPLATE CORE"
      ],
      [
        "config",
        "postgres",
        "TEMPLATE CORE"
      ],
      [
        "raw",
        "postgres",
        "TEMPLATE CORE"
      ],
      [
        "ref",
        "postgres",
        "TEMPLATE CORE"
      ],
      [
        "staging",
        "postgres",
        "TEMPLATE CORE"
      ],
      [
        "util",
        "postgres",
        "TEMPLATE CORE"
      ]
    ],
    "table_counts_by_schema": [
      [
        "ai_monitoring",
        12,
        "OTHER"
      ],
      [
        "compliance",
        4,
        "OTHER"
      ],
      [
        "metadata",
        1,
        "OTHER"
      ],
      [
        "raw",
        5,
        "OTHER"
      ],
      [
        "ref",
        8,
        "OTHER"
      ],
      [
        "staging",
        4,
        "OTHER"
      ],
      [
        "audit",
        12,
        "TEMPLATE CORE"
      ],
      [
        "auth",
        23,
        "TEMPLATE CORE"
      ],
      [
        "business",
        37,
        "TEMPLATE CORE"
      ],
      [
        "util",
        9,
        "TEMPLATE CORE"
      ]
    ],
    "recent_deployments": [
      [
        4,
        "AI Data Vault 2.0 Integration v1.0",
        "2025-06-12 08:25:26.450374-07:00",
        "2025-06-12 08:25:26.450374-07:00",
        "COMPLETED",
        "Successfully deployed complete AI interaction management system with Data Vault 2.0 compliance, Zero Trust security, HIPAA/GDPR audit trails, tenant isolation, and performance monitoring. | AI Data Vault 2.0 deployment completed successfully with 22 tables and essential indexes",
        "postgres"
      ]
    ]
  },
  "data_vault_assessment": {
    "structure_completeness": [
      [
        "Hubs",
        40,
        "GOOD",
        [
          "auth.user_session_h",
          "auth.role_h",
          "raw.user_request_h",
          "compliance.patient_consent_h",
          "audit.ai_security_event_h",
          "audit.system_health_h",
          "audit.security_event_h",
          "audit.error_log_h",
          "audit.ai_compliance_h",
          "audit.audit_event_h",
          "util.query_performance_h",
          "util.cache_performance_h",
          "util.ai_performance_h",
          "auth.session_h",
          "auth.security_policy_h",
          "auth.api_token_h",
          "business.ai_interaction_h",
          "auth.tenant_h",
          "auth.user_h",
          "auth.security_tracking_h",
          "raw.login_attempt_h",
          "staging.login_attempt_h",
          "staging.user_creation_h",
          "business.monitoring_sensor_h",
          "business.ai_session_h",
          "business.business_entity_h",
          "business.service_contract_h",
          "business.note_payable_h",
          "business.asset_h",
          "business.business_trip_h",
          "business.intellectual_property_h",
          "business.tax_record_h",
          "business.ai_observation_h",
          "business.ai_alert_h",
          "business.monitored_entity_h",
          "ai_monitoring.monitored_entity_h",
          "ai_monitoring.ai_analysis_h",
          "ai_monitoring.alert_h",
          "ai_monitoring.zt_access_policies_h",
          "ai_monitoring.zt_security_events_h"
        ]
      ],
      [
        "Links",
        15,
        "GOOD",
        [
          "compliance.patient_user_l",
          "auth.user_role_l",
          "auth.user_session_l",
          "auth.user_token_l",
          "auth.session_token_l",
          "business.user_ai_interaction_l",
          "business.user_ai_session_l",
          "business.ai_session_interaction_l",
          "business.entity_relationship_l",
          "business.asset_ownership_l",
          "business.contract_parties_l",
          "business.ai_observation_alert_l",
          "business.user_ai_observation_l",
          "ai_monitoring.entity_analysis_l",
          "ai_monitoring.analysis_alert_l"
        ]
      ],
      [
        "Reference Tables",
        8,
        "GOOD",
        [
          "ref.entity_type_r",
          "ref.transaction_type_r",
          "ref.compliance_framework_r",
          "ref.tax_code_r",
          "ref.ai_model_r",
          "ref.ai_context_type_r",
          "ref.ai_observation_type_r",
          "ref.ai_alert_type_r"
        ]
      ],
      [
        "Satellites",
        49,
        "GOOD",
        [
          "auth.user_session_s",
          "auth.tenant_profile_s",
          "raw.user_request_details_s",
          "compliance.patient_consent_s",
          "compliance.consent_audit_s",
          "audit.audit_detail_s",
          "audit.error_log_s",
          "audit.system_health_s",
          "audit.ai_security_event_s",
          "audit.ai_compliance_s",
          "audit.security_event_s",
          "util.template_features",
          "util.cache_performance_s",
          "util.query_performance_s",
          "util.ai_performance_s",
          "auth.role_definition_s",
          "auth.session_state_s",
          "auth.security_policy_s",
          "auth.api_token_s",
          "auth.tenant_definition_s",
          "staging.user_validation_s",
          "auth.user_profile_s",
          "auth.user_auth_s",
          "raw.login_details_s",
          "raw.login_attempt_s",
          "auth.token_activity_s",
          "auth.ip_tracking_s",
          "staging.login_status_s",
          "business.ai_interaction_details_s",
          "business.ai_interaction_security_s",
          "business.ai_session_details_s",
          "business.business_entity_profile_s",
          "business.entity_relationship_details_s",
          "business.asset_ownership_terms_s",
          "business.service_contract_terms_s",
          "business.ip_details_s",
          "business.asset_details_s",
          "business.note_payable_terms_s",
          "business.tax_record_details_s",
          "business.trip_details_s",
          "business.ai_observation_details_s",
          "business.ai_alert_details_s",
          "business.monitored_entity_details_s",
          "business.monitoring_sensor_details_s",
          "ai_monitoring.monitored_entity_details_s",
          "ai_monitoring.ai_analysis_results_s",
          "ai_monitoring.alert_details_s",
          "ai_monitoring.zt_access_policies_s",
          "ai_monitoring.zt_security_events_s"
        ]
      ]
    ],
    "naming_compliance": [
      [
        "Hub Tables",
        40,
        31,
        31,
        39,
        "84.17"
      ],
      [
        "Satellite Tables",
        49,
        48,
        48,
        48,
        "97.96"
      ]
    ]
  },
  "tenant_isolation_assessment": {
    "isolation_completeness": [
      [
        "Hub Tables",
        40,
        39,
        1,
        "97.50",
        "GOOD_ISOLATION"
      ],
      [
        "Link Tables",
        15,
        15,
        0,
        "100.00",
        "PERFECT_ISOLATION"
      ]
    ],
    "rls_policies": []
  },
  "performance_analysis": {
    "index_analysis": [
      [
        "PERFORMANCE",
        139,
        [
          "ai_monitoring",
          "audit",
          "auth",
          "business",
          "compliance",
          "raw",
          "ref",
          "staging",
          "util"
        ],
        12,
        127
      ],
      [
        "PRIMARY_KEY",
        121,
        [
          "ai_monitoring",
          "audit",
          "auth",
          "business",
          "compliance",
          "metadata",
          "raw",
          "ref",
          "staging",
          "util"
        ],
        15,
        106
      ],
      [
        "TENANT_ISOLATION",
        21,
        [
          "ai_monitoring",
          "audit",
          "auth",
          "business",
          "compliance",
          "raw",
          "staging"
        ],
        0,
        21
      ],
      [
        "BUSINESS_KEY",
        16,
        [
          "ai_monitoring",
          "auth",
          "business",
          "compliance"
        ],
        2,
        14
      ],
      [
        "UNIQUE_CONSTRAINT",
        9,
        [
          "auth",
          "compliance",
          "metadata",
          "util"
        ],
        3,
        6
      ],
      [
        "HASH_KEY",
        5,
        [
          "auth",
          "compliance"
        ],
        1,
        4
      ],
      [
        "TEMPORAL",
        2,
        [
          "auth"
        ],
        0,
        2
      ]
    ],
    "table_usage": []
  },
  "compliance_analysis": {
    "hipaa_compliance": [
      [
        "Access Logging",
        "PRESENT",
        5,
        "COMPLIANT"
      ],
      [
        "Audit Infrastructure",
        "PRESENT",
        12,
        "COMPLIANT"
      ],
      [
        "Consent Management",
        "PRESENT",
        13,
        "COMPLIANT"
      ],
      [
        "PHI Protection",
        "PRESENT",
        72,
        "COMPLIANT"
      ]
    ],
    "retention_analysis": [
      [
        "ai_monitoring",
        "ai_analysis_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ai_monitoring",
        "ai_analysis_results_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "ai_monitoring",
        "alert_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, acknowledged_date, resolved_date"
      ],
      [
        "ai_monitoring",
        "alert_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ai_monitoring",
        "analysis_alert_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ai_monitoring",
        "entity_analysis_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ai_monitoring",
        "monitored_entity_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, last_accessed_date"
      ],
      [
        "ai_monitoring",
        "monitored_entity_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ai_monitoring",
        "zt_access_policies_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ai_monitoring",
        "zt_access_policies_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, expires_date"
      ],
      [
        "ai_monitoring",
        "zt_security_events_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ai_monitoring",
        "zt_security_events_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "audit",
        "ai_compliance_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "audit",
        "ai_compliance_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, assessment_date, next_assessment_date"
      ],
      [
        "audit",
        "ai_security_event_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "audit",
        "ai_security_event_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "audit",
        "audit_detail_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "audit",
        "audit_event_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "audit",
        "error_log_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "audit",
        "error_log_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "audit",
        "security_event_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "audit",
        "security_event_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "audit",
        "system_health_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "audit",
        "system_health_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "auth",
        "api_token_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "api_token_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "auth",
        "ip_tracking_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "auth",
        "role_definition_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, created_date, last_updated_date"
      ],
      [
        "auth",
        "role_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "security_policy_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "security_policy_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, created_date, last_updated_date"
      ],
      [
        "auth",
        "security_tracking_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "session_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "session_state_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "auth",
        "session_token_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "tenant_definition_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, subscription_start_date, subscription_end_date, last_updated_date, last_updated_by"
      ],
      [
        "auth",
        "tenant_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "tenant_profile_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, subscription_start_date, subscription_end_date, created_date, last_updated_date"
      ],
      [
        "auth",
        "token_activity_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "auth",
        "user_auth_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, last_login_date"
      ],
      [
        "auth",
        "user_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "user_profile_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, created_date, last_updated_date"
      ],
      [
        "auth",
        "user_role_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "user_session_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "user_session_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "auth",
        "user_session_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "auth",
        "user_token_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "ai_alert_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, follow_up_date"
      ],
      [
        "business",
        "ai_alert_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "ai_interaction_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "business",
        "ai_interaction_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "ai_interaction_security_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "business",
        "ai_observation_alert_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "ai_observation_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, human_verification_date"
      ],
      [
        "business",
        "ai_observation_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "ai_session_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "business",
        "ai_session_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "ai_session_interaction_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "asset_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, purchase_date"
      ],
      [
        "business",
        "asset_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "asset_ownership_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "asset_ownership_terms_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, acquisition_date"
      ],
      [
        "business",
        "business_entity_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "business_entity_profile_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, formation_date"
      ],
      [
        "business",
        "business_trip_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "contract_parties_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "entity_relationship_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, effective_date, termination_date"
      ],
      [
        "business",
        "entity_relationship_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "intellectual_property_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "ip_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, creation_date, registration_date, expiration_date"
      ],
      [
        "business",
        "monitored_entity_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "business",
        "monitored_entity_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "monitoring_sensor_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, installation_date, last_maintenance_date"
      ],
      [
        "business",
        "monitoring_sensor_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "note_payable_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "note_payable_terms_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, issue_date, maturity_date"
      ],
      [
        "business",
        "service_contract_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "service_contract_terms_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, contract_start_date, contract_end_date"
      ],
      [
        "business",
        "tax_record_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, record_date"
      ],
      [
        "business",
        "tax_record_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "trip_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, departure_date, return_date"
      ],
      [
        "business",
        "user_ai_interaction_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "user_ai_observation_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "business",
        "user_ai_session_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "compliance",
        "consent_audit_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, review_date"
      ],
      [
        "compliance",
        "patient_consent_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "compliance",
        "patient_consent_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date, consent_date, withdrawal_date, renewal_date, last_updated_by"
      ],
      [
        "compliance",
        "patient_user_l",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "metadata",
        "record_source",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "raw",
        "login_attempt_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "raw",
        "login_attempt_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "raw",
        "login_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "raw",
        "user_request_details_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "raw",
        "user_request_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ref",
        "ai_alert_type_r",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ref",
        "ai_context_type_r",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ref",
        "ai_model_r",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ref",
        "ai_observation_type_r",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "ref",
        "compliance_framework_r",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "effective_date, expiration_date, created_date, last_updated_date"
      ],
      [
        "ref",
        "entity_type_r",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "effective_date, expiration_date, created_date, last_updated_date"
      ],
      [
        "ref",
        "tax_code_r",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "effective_date, expiration_date, created_date, last_updated_date"
      ],
      [
        "ref",
        "transaction_type_r",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "effective_date, expiration_date, created_date, last_updated_date"
      ],
      [
        "staging",
        "login_attempt_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "staging",
        "login_status_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "staging",
        "user_creation_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "staging",
        "user_validation_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "util",
        "ai_performance_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "util",
        "ai_performance_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "util",
        "cache_performance_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "util",
        "cache_performance_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "util",
        "database_version",
        "NO_RETENTION_COLUMNS",
        "NO_TEMPORAL_TRACKING",
        "deployment_date"
      ],
      [
        "util",
        "deployment_log",
        "NO_RETENTION_COLUMNS",
        "NO_TEMPORAL_TRACKING",
        null
      ],
      [
        "util",
        "query_performance_h",
        "NO_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date"
      ],
      [
        "util",
        "query_performance_s",
        "HAS_RETENTION_COLUMNS",
        "HAS_TEMPORAL_TRACKING",
        "load_date, load_end_date"
      ],
      [
        "util",
        "template_features",
        "NO_RETENTION_COLUMNS",
        "NO_TEMPORAL_TRACKING",
        "deployment_date"
      ]
    ]
  },
  "api_business_analysis": {
    "api_coverage": [
      [
        "api",
        "UTILITY",
        17,
        [
          "admin_reset_password",
          "change_password",
          "consent_create",
          "consent_status",
          "forgot_password_request",
          "security_policies_get",
          "security_rate_limit_check",
          "system_health_check",
          "test_all_endpoints",
          "test_existing_endpoints",
          "token_validate",
          "tokens_generate",
          "tokens_revoke",
          "tokens_validate",
          "validate_contract",
          "validate_fixed_contract",
          "validate_secure_contract"
        ]
      ],
      [
        "api",
        "AI_INTEGRATION",
        13,
        [
          "ai_acknowledge_alert",
          "ai_chat_history",
          "ai_create_session",
          "ai_get_active_alerts",
          "ai_get_observation_analytics",
          "ai_get_observations",
          "ai_log_observation",
          "ai_monitoring_acknowledge_alert",
          "ai_monitoring_get_alerts",
          "ai_monitoring_get_entity_timeline",
          "ai_monitoring_ingest",
          "ai_monitoring_system_health",
          "ai_secure_chat"
        ]
      ],
      [
        "api",
        "USER_MANAGEMENT",
        7,
        [
          "tenant_register",
          "tenant_roles_list",
          "tenants_list",
          "user_register",
          "users_profile_get",
          "users_profile_update",
          "users_register"
        ]
      ],
      [
        "api",
        "AUTHENTICATION",
        6,
        [
          "auth_complete_login",
          "auth_login",
          "auth_login_test",
          "auth_logout",
          "auth_validate_session",
          "test_auth_with_roles"
        ]
      ],
      [
        "api",
        "AUDIT_COMPLIANCE",
        1,
        [
          "security_audit"
        ]
      ],
      [
        "auth",
        "UTILITY",
        27,
        [
          "bulk_expire_sessions",
          "change_password",
          "check_account_lockout",
          "check_rate_limit_enhanced",
          "cleanup_expired_sessions",
          "create_session_with_token",
          "establish_base_security_policy",
          "generate_api_token",
          "generate_policy_bk",
          "generate_security_report",
          "generate_session_token",
          "generate_token_for_session",
          "reset_password",
          "revoke_token",
          "revoke_token_enhanced",
          "rollback_step_13",
          "update_security_policy",
          "update_token_usage",
          "validate_hipaa_policy",
          "validate_password_policy",
          "validate_session",
          "validate_session_enhanced",
          "validate_session_json",
          "validate_session_optimized",
          "validate_token_and_session",
          "validate_token_comprehensive",
          "verify_step_13_implementation"
        ]
      ],
      [
        "auth",
        "USER_MANAGEMENT",
        7,
        [
          "get_tenant_definition",
          "get_tenant_security_policy",
          "get_user_salt",
          "register_tenant",
          "register_user",
          "update_tenant_definition",
          "update_user_password_direct"
        ]
      ],
      [
        "auth",
        "AUTHENTICATION",
        6,
        [
          "get_cached_user_auth",
          "login_user",
          "monitor_failed_logins",
          "process_failed_login",
          "process_valid_login",
          "process_valid_login_enhanced"
        ]
      ],
      [
        "auth",
        "AI_INTEGRATION",
        2,
        [
          "maintain_security_state",
          "validate_ai_access"
        ]
      ],
      [
        "business",
        "UTILITY",
        3,
        [
          "analyze_content_safety",
          "transfer_asset_ownership",
          "validate_market_rates"
        ]
      ],
      [
        "business",
        "AI_INTEGRATION",
        3,
        [
          "create_ai_session",
          "get_ai_interaction_history",
          "store_ai_interaction"
        ]
      ],
      [
        "business",
        "BUSINESS_LOGIC",
        1,
        [
          "create_business_entity"
        ]
      ],
      [
        "util",
        "UTILITY",
        28,
        [
          "analyze_field_length_usage",
          "analyze_query_performance",
          "check_system_health",
          "current_load_date",
          "final_security_report",
          "generate_bk",
          "generate_performance_report",
          "generate_security_report",
          "get_connection_info",
          "get_record_source",
          "hash_binary",
          "hash_concat",
          "optimize_table_statistics",
          "refresh_performance_caches",
          "rollback_step_14",
          "rollback_step_15",
          "rollback_step_16",
          "rollback_step_21",
          "simulate_connection_test",
          "test_api_security",
          "test_api_security_final",
          "test_record_source",
          "test_registration",
          "test_role_permissions",
          "validate_template_readiness",
          "verify_step_14_implementation",
          "verify_step_15_implementation",
          "verify_step_16_implementation"
        ]
      ],
      [
        "util",
        "AUDIT_COMPLIANCE",
        12,
        [
          "audit_track_bridge",
          "audit_track_default",
          "audit_track_dispatcher",
          "audit_track_hub",
          "audit_track_link",
          "audit_track_reference",
          "audit_track_satellite",
          "create_audit_triggers",
          "create_audit_triggers_safe",
          "log_audit_event",
          "log_deployment_complete",
          "log_deployment_start"
        ]
      ],
      [
        "util",
        "AI_INTEGRATION",
        1,
        [
          "schedule_performance_maintenance"
        ]
      ],
      [
        "util",
        "USER_MANAGEMENT",
        1,
        [
          "process_hex_tenant"
        ]
      ]
    ],
    "entity_analysis": [
      [
        "auth",
        "user",
        3,
        3,
        "WELL_MODELED",
        6
      ],
      [
        "auth",
        "session",
        1,
        2,
        "BASIC_MODELING",
        3
      ],
      [
        "business",
        "ai_interaction",
        2,
        1,
        "WELL_MODELED",
        3
      ],
      [
        "business",
        "ai_observation",
        1,
        2,
        "BASIC_MODELING",
        3
      ],
      [
        "business",
        "ai_session",
        1,
        2,
        "BASIC_MODELING",
        3
      ],
      [
        "business",
        "asset",
        2,
        1,
        "WELL_MODELED",
        3
      ],
      [
        "ai_monitoring",
        "alert",
        1,
        1,
        "BASIC_MODELING",
        2
      ],
      [
        "auth",
        "role",
        1,
        1,
        "BASIC_MODELING",
        2
      ],
      [
        "auth",
        "tenant",
        2,
        0,
        "BASIC_MODELING",
        2
      ],
      [
        "auth",
        "user_session",
        1,
        1,
        "BASIC_MODELING",
        2
      ],
      [
        "ai_monitoring",
        "ai_analysis",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "ai_monitoring",
        "monitored_entity",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "ai_monitoring",
        "zt_access_policies",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "ai_monitoring",
        "zt_security_events",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "audit",
        "ai_compliance",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "audit",
        "ai_security_event",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "audit",
        "error_log",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "audit",
        "security_event",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "auth",
        "api_token",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "auth",
        "security_policy",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "business",
        "ai_alert",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "business",
        "business_entity",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "business",
        "monitored_entity",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "business",
        "monitoring_sensor",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "business",
        "note_payable",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "business",
        "service_contract",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "business",
        "tax_record",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "compliance",
        "patient_consent",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "raw",
        "login_attempt",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "raw",
        "user_request",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "util",
        "ai_performance",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "util",
        "cache_performance",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "util",
        "query_performance",
        1,
        0,
        "BASIC_MODELING",
        1
      ],
      [
        "audit",
        "audit_event",
        0,
        0,
        "MINIMAL_MODELING",
        0
      ],
      [
        "audit",
        "systemealth",
        0,
        0,
        "MINIMAL_MODELING",
        0
      ],
      [
        "auth",
        "security_tracking",
        0,
        0,
        "MINIMAL_MODELING",
        0
      ],
      [
        "business",
        "business_trip",
        0,
        0,
        "MINIMAL_MODELING",
        0
      ],
      [
        "business",
        "intellectual_property",
        0,
        0,
        "MINIMAL_MODELING",
        0
      ],
      [
        "staging",
        "login_attempt",
        0,
        0,
        "MINIMAL_MODELING",
        0
      ],
      [
        "staging",
        "user_creation",
        0,
        0,
        "MINIMAL_MODELING",
        0
      ]
    ]
  },
  "production_readiness": {
    "readiness_assessment": [
      [
        "Authentication",
        "Auth Functions",
        "READY",
        42,
        1,
        3
      ],
      [
        "Compliance",
        "Audit Tables",
        "READY",
        12,
        2,
        3
      ],
      [
        "Core Infrastructure",
        "Schemas",
        "READY",
        5,
        5,
        3
      ],
      [
        "Data Vault",
        "Hub Tables",
        "READY",
        40,
        3,
        3
      ],
      [
        "Security",
        "Tenant Isolation",
        "READY",
        1,
        1,
        3
      ]
    ],
    "health_metrics": [],
    "missing_components": [
      [
        "auth.tenant_h",
        "Table",
        "CRITICAL",
        "PRESENT",
        "OK"
      ],
      [
        "auth.user_h",
        "Table",
        "CRITICAL",
        "PRESENT",
        "OK"
      ],
      [
        "util.current_load_date",
        "Function",
        "CRITICAL",
        "PRESENT",
        "OK"
      ],
      [
        "util.hash_binary",
        "Function",
        "CRITICAL",
        "PRESENT",
        "OK"
      ],
      [
        "api schema",
        "Schema",
        "HIGH",
        "PRESENT",
        "OK"
      ],
      [
        "audit schema",
        "Schema",
        "HIGH",
        "PRESENT",
        "OK"
      ],
      [
        "business schema",
        "Schema",
        "MEDIUM",
        "PRESENT",
        "OK"
      ]
    ]
  },
  "authentication_system": {
    "auth_tables": [
      [
        "auth",
        "role_definition_s",
        null,
        "AUTHORIZATION"
      ],
      [
        "auth",
        "role_h",
        null,
        "AUTHORIZATION"
      ],
      [
        "auth",
        "ip_tracking_s",
        "Satellite table tracking IP address activity patterns for rate limiting, geographical monitoring, and suspicious activity detection supporting comprehensive security policies.",
        "OTHER_AUTH"
      ],
      [
        "auth",
        "security_policy_h",
        null,
        "SECURITY_POLICY"
      ],
      [
        "auth",
        "security_policy_s",
        null,
        "SECURITY_POLICY"
      ],
      [
        "auth",
        "security_tracking_h",
        "Hub table for security tracking entities managing rate limiting, threat detection, and comprehensive security monitoring across tenant environments.",
        "SECURITY_POLICY"
      ],
      [
        "auth",
        "session_h",
        null,
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "session_state_s",
        null,
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "user_session_h",
        null,
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "user_session_l",
        null,
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "user_session_s",
        null,
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "tenant_definition_s",
        null,
        "TENANT_MANAGEMENT"
      ],
      [
        "auth",
        "tenant_h",
        null,
        "TENANT_MANAGEMENT"
      ],
      [
        "auth",
        "tenant_profile_s",
        null,
        "TENANT_MANAGEMENT"
      ],
      [
        "auth",
        "api_token_h",
        "Hub table for API token entities maintaining unique identifiers and tenant context for comprehensive token lifecycle management in multi-tenant environments.",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "api_token_s",
        "Satellite table containing detailed API token information including lifecycle status, security attributes, and comprehensive usage tracking for regulatory compliance and security monitoring.",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "session_token_l",
        "Link table establishing relationships between user sessions and API tokens enabling integrated authentication workflows and comprehensive session management.",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "token_activity_s",
        "Satellite table tracking comprehensive API token activity including access patterns, endpoint usage, and security events for monitoring and compliance reporting.",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "user_token_l",
        null,
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "user_auth_s",
        null,
        "USER_MANAGEMENT"
      ],
      [
        "auth",
        "user_h",
        null,
        "USER_MANAGEMENT"
      ],
      [
        "auth",
        "user_profile_s",
        null,
        "USER_MANAGEMENT"
      ],
      [
        "auth",
        "user_role_l",
        null,
        "USER_MANAGEMENT"
      ]
    ],
    "token_system": [
      [
        "api_token_h",
        "api_token_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "api_token_h",
        "api_token_bk",
        "character varying",
        255,
        "NO",
        null,
        null
      ],
      [
        "api_token_h",
        "tenant_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "api_token_h",
        "load_date",
        "timestamp with time zone",
        null,
        "YES",
        "util.current_load_date()",
        null
      ],
      [
        "api_token_h",
        "record_source",
        "character varying",
        100,
        "NO",
        "util.get_record_source()",
        null
      ],
      [
        "api_token_s",
        "api_token_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "api_token_s",
        "load_date",
        "timestamp with time zone",
        null,
        "NO",
        "util.current_load_date()",
        null
      ],
      [
        "api_token_s",
        "load_end_date",
        "timestamp with time zone",
        null,
        "YES",
        null,
        null
      ],
      [
        "api_token_s",
        "hash_diff",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "api_token_s",
        "token_hash",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "api_token_s",
        "token_type",
        "character varying",
        50,
        "NO",
        null,
        null
      ],
      [
        "api_token_s",
        "expires_at",
        "timestamp with time zone",
        null,
        "NO",
        null,
        null
      ],
      [
        "api_token_s",
        "is_revoked",
        "boolean",
        null,
        "NO",
        "false",
        null
      ],
      [
        "api_token_s",
        "revocation_reason",
        "text",
        null,
        "YES",
        null,
        null
      ],
      [
        "api_token_s",
        "scope",
        "ARRAY",
        null,
        "NO",
        null,
        null
      ],
      [
        "api_token_s",
        "last_used_at",
        "timestamp with time zone",
        null,
        "YES",
        null,
        null
      ],
      [
        "api_token_s",
        "created_by",
        "character varying",
        100,
        "YES",
        "SESSION_USER",
        null
      ],
      [
        "api_token_s",
        "revoked_by",
        "character varying",
        100,
        "YES",
        null,
        null
      ],
      [
        "api_token_s",
        "revoked_at",
        "timestamp with time zone",
        null,
        "YES",
        null,
        null
      ],
      [
        "api_token_s",
        "record_source",
        "character varying",
        100,
        "NO",
        "util.get_record_source()",
        null
      ],
      [
        "session_token_l",
        "session_token_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_token_l",
        "session_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_token_l",
        "api_token_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_token_l",
        "tenant_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_token_l",
        "load_date",
        "timestamp with time zone",
        null,
        "YES",
        "util.current_load_date()",
        null
      ],
      [
        "session_token_l",
        "record_source",
        "character varying",
        100,
        "NO",
        "util.get_record_source()",
        null
      ],
      [
        "token_activity_s",
        "api_token_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "token_activity_s",
        "load_date",
        "timestamp with time zone",
        null,
        "NO",
        "util.current_load_date()",
        null
      ],
      [
        "token_activity_s",
        "load_end_date",
        "timestamp with time zone",
        null,
        "YES",
        null,
        null
      ],
      [
        "token_activity_s",
        "hash_diff",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "token_activity_s",
        "last_activity_timestamp",
        "timestamp with time zone",
        null,
        "NO",
        null,
        null
      ],
      [
        "token_activity_s",
        "activity_type",
        "character varying",
        50,
        "NO",
        null,
        null
      ],
      [
        "token_activity_s",
        "endpoint_accessed",
        "character varying",
        500,
        "YES",
        null,
        null
      ],
      [
        "token_activity_s",
        "ip_address",
        "inet",
        null,
        "YES",
        null,
        null
      ],
      [
        "token_activity_s",
        "user_agent",
        "text",
        null,
        "YES",
        null,
        null
      ],
      [
        "token_activity_s",
        "request_method",
        "character varying",
        10,
        "YES",
        null,
        null
      ],
      [
        "token_activity_s",
        "response_status",
        "integer",
        null,
        "YES",
        null,
        null
      ],
      [
        "token_activity_s",
        "activity_metadata",
        "jsonb",
        null,
        "YES",
        null,
        null
      ],
      [
        "token_activity_s",
        "record_source",
        "character varying",
        100,
        "NO",
        "util.get_record_source()",
        null
      ],
      [
        "user_auth_s",
        "password_reset_token",
        "character varying",
        255,
        "YES",
        null,
        null
      ],
      [
        "user_session_h",
        "session_token",
        "text",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_token_l",
        "user_token_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_token_l",
        "user_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_token_l",
        "api_token_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_token_l",
        "tenant_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_token_l",
        "load_date",
        "timestamp with time zone",
        null,
        "YES",
        "util.current_load_date()",
        null
      ],
      [
        "user_token_l",
        "record_source",
        "character varying",
        100,
        "NO",
        "util.get_record_source()",
        null
      ]
    ],
    "session_system": [
      [
        "security_policy_s",
        "session_timeout_minutes",
        "integer",
        null,
        "YES",
        "60",
        null
      ],
      [
        "session_h",
        "session_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_h",
        "session_bk",
        "character varying",
        255,
        "NO",
        null,
        null
      ],
      [
        "session_h",
        "tenant_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_h",
        "load_date",
        "timestamp with time zone",
        null,
        "YES",
        "util.current_load_date()",
        null
      ],
      [
        "session_h",
        "record_source",
        "character varying",
        100,
        "NO",
        null,
        null
      ],
      [
        "session_state_s",
        "session_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_state_s",
        "load_date",
        "timestamp with time zone",
        null,
        "NO",
        "util.current_load_date()",
        null
      ],
      [
        "session_state_s",
        "load_end_date",
        "timestamp with time zone",
        null,
        "YES",
        null,
        null
      ],
      [
        "session_state_s",
        "hash_diff",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_state_s",
        "session_start",
        "timestamp with time zone",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_state_s",
        "session_end",
        "timestamp with time zone",
        null,
        "YES",
        null,
        null
      ],
      [
        "session_state_s",
        "ip_address",
        "inet",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_state_s",
        "user_agent",
        "text",
        null,
        "YES",
        null,
        null
      ],
      [
        "session_state_s",
        "session_data",
        "jsonb",
        null,
        "YES",
        null,
        null
      ],
      [
        "session_state_s",
        "session_status",
        "character varying",
        20,
        "NO",
        null,
        null
      ],
      [
        "session_state_s",
        "last_activity",
        "timestamp with time zone",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_state_s",
        "record_source",
        "character varying",
        100,
        "NO",
        null,
        null
      ],
      [
        "session_token_l",
        "session_token_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_token_l",
        "session_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_token_l",
        "api_token_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_token_l",
        "tenant_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "session_token_l",
        "load_date",
        "timestamp with time zone",
        null,
        "YES",
        "util.current_load_date()",
        null
      ],
      [
        "session_token_l",
        "record_source",
        "character varying",
        100,
        "NO",
        "util.get_record_source()",
        null
      ],
      [
        "user_session_h",
        "session_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_session_h",
        "session_token",
        "text",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_session_h",
        "load_date",
        "timestamp with time zone",
        null,
        "NO",
        "util.current_load_date()",
        null
      ],
      [
        "user_session_h",
        "record_source",
        "text",
        null,
        "NO",
        "util.get_record_source()",
        null
      ],
      [
        "user_session_l",
        "link_user_session_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_session_l",
        "user_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_session_l",
        "session_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_session_l",
        "tenant_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_session_l",
        "load_date",
        "timestamp with time zone",
        null,
        "YES",
        "util.current_load_date()",
        null
      ],
      [
        "user_session_l",
        "record_source",
        "character varying",
        100,
        "NO",
        null,
        null
      ],
      [
        "user_session_s",
        "session_hk",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_session_s",
        "load_date",
        "timestamp with time zone",
        null,
        "NO",
        "util.current_load_date()",
        null
      ],
      [
        "user_session_s",
        "load_end_date",
        "timestamp with time zone",
        null,
        "YES",
        null,
        null
      ],
      [
        "user_session_s",
        "hash_diff",
        "bytea",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_session_s",
        "ip_address",
        "inet",
        null,
        "YES",
        null,
        null
      ],
      [
        "user_session_s",
        "user_agent",
        "text",
        null,
        "YES",
        null,
        null
      ],
      [
        "user_session_s",
        "created_at",
        "timestamp with time zone",
        null,
        "NO",
        "CURRENT_TIMESTAMP",
        null
      ],
      [
        "user_session_s",
        "expires_at",
        "timestamp with time zone",
        null,
        "NO",
        null,
        null
      ],
      [
        "user_session_s",
        "is_active",
        "boolean",
        null,
        "NO",
        "true",
        null
      ],
      [
        "user_session_s",
        "record_source",
        "text",
        null,
        "NO",
        "util.get_record_source()",
        null
      ]
    ],
    "auth_functions": [
      [
        "auth",
        "generate_policy_bk",
        "p_tenant_hk bytea, p_policy_name character varying",
        "character varying",
        "plpgsql",
        "\nBEGIN\n    RETURN 'POLICY_' || substr(encode(p_tenant_hk, 'hex'), 1, 8) || '_' || p_policy_name;\nEND;\n",
        null,
        "GENERATION"
      ],
      [
        "auth",
        "generate_security_report",
        "IN p_tenant_hk bytea, IN p_start_date timestamp with time zone, IN p_end_date timestamp with time zone",
        null,
        "plpgsql",
        "\nDECLARE\n    v_report_data JSONB;\n    v_failed_logins INTEGER;\n    v_successful_logins INTEGER;\n    v_locked_accounts INTEGER;\n    v_security_events INTEGER;\n    v_critical_errors INTEGER;\nBEGIN\n    -- Gather security metrics\n    SELECT COUNT(*) INTO v_failed_logins\n    FROM staging.login_status_s sls\n    JOIN staging.login_attempt_h slh ON sls.login_attempt_hk = slh.login_attempt_hk\n    WHERE slh.tenant_hk = p_tenant_hk\n    AND sls.validation_status IN ('INVALID_PASSWORD', 'INVALID_USER')\n    AND sls.attempt_timestamp BETWEEN p_start_date AND p_end_date\n    AND sls.load_end_date IS NULL;\n    \n    SELECT COUNT(*) INTO v_successful_logins\n    FROM staging.login_status_s sls\n    JOIN staging.login_attempt_h slh ON sls.login_attempt_hk = slh.login_attempt_hk\n    WHERE slh.tenant_hk = p_tenant_hk\n    AND sls.validation_status = 'VALID'\n    AND sls.attempt_timestamp BETWEEN p_start_date AND p_end_date\n    AND sls.load_end_date IS NULL;\n    \n    SELECT COUNT(*) INTO v_locked_accounts\n    FROM auth.user_auth_s uas\n    JOIN auth.user_h uh ON uas.user_hk = uh.user_hk\n    WHERE uh.tenant_hk = p_tenant_hk\n    AND uas.account_locked = TRUE\n    AND uas.load_date BETWEEN p_start_date AND p_end_date\n    AND uas.load_end_date IS NULL;\n    \n    SELECT COUNT(*) INTO v_security_events\n    FROM audit.security_event_s ses\n    JOIN audit.security_event_h seh ON ses.security_event_hk = seh.security_event_hk\n    WHERE seh.tenant_hk = p_tenant_hk\n    AND ses.load_date BETWEEN p_start_date AND p_end_date\n    AND ses.load_end_date IS NULL;\n    \n    SELECT COUNT(*) INTO v_critical_errors\n    FROM audit.error_log_s els\n    JOIN audit.error_log_h elh ON els.error_log_hk = elh.error_log_hk\n    WHERE elh.tenant_hk = p_tenant_hk\n    AND els.error_severity = 'CRITICAL'\n    AND els.first_occurrence BETWEEN p_start_date AND p_end_date\n    AND els.load_end_date IS NULL;\n    \n    -- Build comprehensive report\n    v_report_data := jsonb_build_object(\n        'report_period', jsonb_build_object(\n            'start_date', p_start_date,\n            'end_date', p_end_date\n        ),\n        'authentication_metrics', jsonb_build_object(\n            'successful_logins', v_successful_logins,\n            'failed_logins', v_failed_logins,\n            'success_rate', CASE \n                WHEN (v_successful_logins + v_failed_logins) > 0 \n                THEN ROUND((v_successful_logins::DECIMAL / (v_successful_logins + v_failed_logins)) * 100, 2)\n                ELSE 0 \n            END\n        ),\n        'security_metrics', jsonb_build_object(\n            'locked_accounts', v_locked_accounts,\n            'security_events', v_security_events,\n            'critical_errors', v_critical_errors\n        )\n    );\n    \n    -- Log the report generation\n    PERFORM audit.log_security_event(\n        p_tenant_hk,\n        'SECURITY_REPORT_GENERATED',\n        format('Security report generated for period %s to %s', p_start_date, p_end_date),\n        v_report_data\n    );\n    \n    RAISE NOTICE 'Security report generated: %', v_report_data;\nEND;\n",
        null,
        "GENERATION"
      ],
      [
        "auth",
        "login_user",
        "IN p_username character varying, IN p_password text, IN p_ip_address inet, IN p_user_agent text, OUT p_success boolean, OUT p_message text, OUT p_tenant_list jsonb, OUT p_session_token text, OUT p_user_data jsonb, IN p_auto_login boolean DEFAULT true",
        null,
        "plpgsql",
        "\nDECLARE\n    v_tenant_hk BYTEA;\n    v_login_attempt_hk BYTEA;\n    v_user_hk BYTEA;\n    v_validation_result JSONB;\nBEGIN\n    -- Initialize outputs\n    p_success := FALSE;\n    p_message := 'Authentication failed';\n    p_tenant_list := NULL;\n    p_session_token := NULL;\n    p_user_data := NULL;\n\n    -- Get system tenant for validation\n    SELECT tenant_hk INTO v_tenant_hk\n    FROM auth.tenant_h\n    LIMIT 1;\n    \n    IF v_tenant_hk IS NULL THEN\n        p_message := 'No tenant available for authentication';\n        RETURN;\n    END IF;\n    \n    -- Record login attempt\n    v_login_attempt_hk := raw.capture_login_attempt(\n        v_tenant_hk,\n        p_username,\n        p_password,\n        p_ip_address,\n        p_user_agent\n    );\n    \n    -- Validate credentials\n    v_validation_result := staging.validate_login_credentials(v_login_attempt_hk);\n    \n    -- Process results\n    IF (v_validation_result->>'status') != 'VALID' THEN\n        p_success := FALSE;\n        p_message := CASE \n            WHEN (v_validation_result->>'status') = 'INVALID_USER' THEN 'User not found'\n            WHEN (v_validation_result->>'status') = 'INVALID_PASSWORD' THEN 'Invalid password'\n            WHEN (v_validation_result->>'status') = 'LOCKED' THEN 'Account is locked'\n            ELSE 'Login failed'\n        END;\n        RETURN;\n    END IF;\n    \n    -- Success!\n    p_success := TRUE;\n    p_message := 'Authentication successful';\n    v_user_hk := decode(v_validation_result->>'user_hk', 'hex');\n    \n    -- Get tenant list for this user\n    SELECT jsonb_agg(\n        jsonb_build_object(\n            'tenant_id', t.tenant_bk,\n            'tenant_name', COALESCE(tps.tenant_name, t.tenant_bk)\n        )\n    ) INTO p_tenant_list\n    FROM auth.user_h u\n    JOIN auth.tenant_h t ON u.tenant_hk = t.tenant_hk\n    LEFT JOIN auth.tenant_profile_s tps ON t.tenant_hk = tps.tenant_hk \n        AND tps.load_end_date IS NULL\n    WHERE u.user_hk = v_user_hk;\n    \n    -- If single tenant, auto-create session\n    IF p_auto_login AND jsonb_array_length(p_tenant_list) = 1 THEN\n        -- Create session token (simplified for example)\n        p_session_token := encode(gen_random_bytes(32), 'hex');\n        \n        -- Get user data\n        SELECT jsonb_build_object(\n            'user_id', u.user_bk,\n            'email', uas.username,\n            'first_name', COALESCE(ups.first_name, ''),\n            'last_name', COALESCE(ups.last_name, '')\n        ) INTO p_user_data\n        FROM auth.user_h u\n        JOIN auth.user_auth_s uas ON u.user_hk = uas.user_hk\n        LEFT JOIN auth.user_profile_s ups ON u.user_hk = ups.user_hk\n        WHERE u.user_hk = v_user_hk\n        AND uas.load_end_date IS NULL\n        AND (ups.load_end_date IS NULL OR ups.load_end_date IS NULL);\n    END IF;\n    \nEXCEPTION WHEN OTHERS THEN\n    p_success := FALSE;\n    p_message := 'System error during authentication';\nEND;\n",
        null,
        "LOGIN_AUTHENTICATION"
      ],
      [
        "auth",
        "monitor_failed_logins",
        "p_tenant_hk bytea, p_time_window interval DEFAULT '01:00:00'::interval",
        "TABLE(suspicious_ips inet[], failed_attempts_count integer, unique_usernames_targeted integer, threat_assessment character varying)",
        "plpgsql",
        "\nDECLARE\n    v_suspicious_ips INET[];\n    v_failed_count INTEGER;\n    v_unique_users INTEGER;\n    v_threat_level VARCHAR(20);\nBEGIN\n    -- Analyze failed login patterns\n    WITH failed_login_analysis AS (\n        SELECT \n            sls.ip_address,\n            COUNT(*) as attempt_count,\n            COUNT(DISTINCT sls.username) as unique_users\n        FROM staging.login_status_s sls\n        JOIN staging.login_attempt_h slh ON sls.login_attempt_hk = slh.login_attempt_hk\n        WHERE slh.tenant_hk = p_tenant_hk\n        AND sls.validation_status IN ('INVALID_PASSWORD', 'INVALID_USER')\n        AND sls.attempt_timestamp > (CURRENT_TIMESTAMP - p_time_window)\n        AND sls.load_end_date IS NULL\n        GROUP BY sls.ip_address\n        HAVING COUNT(*) >= 5 -- Threshold for suspicious activity\n    )\n    SELECT \n        array_agg(ip_address),\n        SUM(attempt_count)::INTEGER,\n        SUM(unique_users)::INTEGER\n    INTO \n        v_suspicious_ips,\n        v_failed_count,\n        v_unique_users\n    FROM failed_login_analysis;\n    \n    -- Determine threat level\n    IF v_failed_count > 100 OR v_unique_users > 20 THEN\n        v_threat_level := 'CRITICAL';\n    ELSIF v_failed_count > 50 OR v_unique_users > 10 THEN\n        v_threat_level := 'HIGH';\n    ELSIF v_failed_count > 20 OR v_unique_users > 5 THEN\n        v_threat_level := 'MEDIUM';\n    ELSE\n        v_threat_level := 'LOW';\n    END IF;\n    \n    -- Log security event if suspicious activity detected\n    IF v_failed_count > 0 THEN\n        PERFORM audit.log_security_event(\n            p_tenant_hk,\n            'SUSPICIOUS_LOGIN_PATTERN',\n            format('Detected %s failed login attempts from %s IP addresses targeting %s users', \n                   v_failed_count, array_length(v_suspicious_ips, 1), v_unique_users),\n            jsonb_build_object(\n                'failed_attempts', v_failed_count,\n                'suspicious_ips', v_suspicious_ips,\n                'unique_users_targeted', v_unique_users,\n                'time_window', p_time_window,\n                'threat_level', v_threat_level\n            )\n        );\n    END IF;\n    \n    RETURN QUERY SELECT \n        COALESCE(v_suspicious_ips, ARRAY[]::INET[]),\n        COALESCE(v_failed_count, 0),\n        COALESCE(v_unique_users, 0),\n        v_threat_level;\nEND;\n",
        null,
        "LOGIN_AUTHENTICATION"
      ],
      [
        "auth",
        "process_failed_login",
        "p_tenant_hk bytea, p_username character varying, p_failure_reason character varying, p_ip_address inet",
        "boolean",
        "plpgsql",
        "\nDECLARE\n    v_user_hk BYTEA;\n    v_current_attempts INTEGER;\n    v_lockout_threshold INTEGER;\n    v_lockout_duration_minutes INTEGER;\n    v_new_lockout_until TIMESTAMP WITH TIME ZONE;\n    \n    -- Individual scalar variables instead of ROWTYPE\n    v_current_username VARCHAR(255);\n    v_current_password_hash BYTEA;\n    v_current_password_salt BYTEA;\n    v_current_last_login_date TIMESTAMP WITH TIME ZONE;\n    v_current_password_last_changed TIMESTAMP WITH TIME ZONE;\n    v_current_must_change_password BOOLEAN;\nBEGIN\n    -- Log the function call\n    RAISE NOTICE 'Processing failed login for username: %, reason: %', p_username, p_failure_reason;\n    \n    -- Get user hash key and current auth record data\n    SELECT \n        uh.user_hk,\n        uas.username,\n        uas.password_hash,\n        uas.password_salt,\n        uas.last_login_date,\n        uas.password_last_changed,\n        uas.must_change_password,\n        COALESCE(uas.failed_login_attempts, 0)\n    INTO \n        v_user_hk,\n        v_current_username,\n        v_current_password_hash,\n        v_current_password_salt,\n        v_current_last_login_date,\n        v_current_password_last_changed,\n        v_current_must_change_password,\n        v_current_attempts\n    FROM auth.user_h uh\n    JOIN auth.user_auth_s uas ON uh.user_hk = uas.user_hk\n    WHERE uh.tenant_hk = p_tenant_hk\n    AND uas.username = p_username\n    AND uas.load_end_date IS NULL\n    ORDER BY uas.load_date DESC\n    LIMIT 1;\n\n    -- If user not found, return false (don't reveal user existence)\n    IF v_user_hk IS NULL THEN\n        RAISE NOTICE 'User not found for failed login processing: %', p_username;\n        RETURN FALSE;\n    END IF;\n\n    RAISE NOTICE 'Found user HK: %, current failed attempts: %', \n        encode(v_user_hk, 'hex'), v_current_attempts;\n\n    -- Get security policy for lockout settings\n    SELECT \n        COALESCE(sp.account_lockout_threshold, 5),\n        COALESCE(sp.account_lockout_duration_minutes, 30)\n    INTO \n        v_lockout_threshold,\n        v_lockout_duration_minutes\n    FROM auth.security_policy_h sph\n    JOIN auth.security_policy_s sp ON sph.security_policy_hk = sp.security_policy_hk\n    WHERE sph.tenant_hk = p_tenant_hk\n    AND sp.is_active = TRUE \n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n\n    -- Use defaults if no policy found\n    v_lockout_threshold := COALESCE(v_lockout_threshold, 5);\n    v_lockout_duration_minutes := COALESCE(v_lockout_duration_minutes, 30);\n    \n    RAISE NOTICE 'Using lockout threshold: %, duration: % minutes', \n        v_lockout_threshold, v_lockout_duration_minutes;\n\n    -- Calculate new failed attempts count\n    v_current_attempts := v_current_attempts + 1;\n    \n    -- Determine if account should be locked\n    IF v_current_attempts >= v_lockout_threshold THEN\n        v_new_lockout_until := CURRENT_TIMESTAMP + (v_lockout_duration_minutes || ' minutes')::INTERVAL;\n        RAISE NOTICE 'Account will be locked until: %', v_new_lockout_until;\n    ELSE\n        v_new_lockout_until := NULL;\n        RAISE NOTICE 'Account not locked yet. Attempts: %/%', v_current_attempts, v_lockout_threshold;\n    END IF;\n\n    -- CRITICAL FIX: Proper Data Vault 2.0 historization to avoid constraint violations\n    BEGIN\n        -- STEP 1: End-date the current record FIRST\n        UPDATE auth.user_auth_s\n        SET load_end_date = util.current_load_date()\n        WHERE user_hk = v_user_hk\n        AND load_end_date IS NULL;\n        \n        RAISE NOTICE 'End-dated current auth record';\n\n        -- STEP 2: Insert new record with updated failed attempts\n        INSERT INTO auth.user_auth_s (\n            user_hk,\n            load_date,\n            hash_diff,\n            username,\n            password_hash,\n            password_salt,\n            last_login_date,\n            password_last_changed,\n            failed_login_attempts,\n            account_locked,\n            account_locked_until,\n            must_change_password,\n            record_source\n        ) VALUES (\n            v_user_hk,\n            util.current_load_date(),\n            util.hash_binary(v_current_username || 'FAILED_LOGIN_' || v_current_attempts::text || '_' || CURRENT_TIMESTAMP::text),\n            v_current_username,\n            v_current_password_hash,\n            v_current_password_salt,\n            v_current_last_login_date,\n            v_current_password_last_changed,\n            v_current_attempts,\n            CASE WHEN v_current_attempts >= v_lockout_threshold THEN TRUE ELSE FALSE END,\n            v_new_lockout_until,\n            v_current_must_change_password,\n            util.get_record_source()\n        );\n        \n        RAISE NOTICE '\u2705 Successfully updated failed login attempts to: %', v_current_attempts;\n        \n        -- Note: Security tracking removed to avoid table dependency issues\n        -- This can be added back once the security tracking schema is confirmed\n        \n        RETURN TRUE;\n\n    EXCEPTION WHEN OTHERS THEN\n        RAISE NOTICE '\u274c Error updating failed login attempts: % - %', SQLSTATE, SQLERRM;\n        RAISE NOTICE 'Rolling back transaction...';\n        RETURN FALSE;\n    END;\n\nEND;\n",
        "FINAL VERSION: Processes failed login attempts with proper Data Vault 2.0 historization. \nUses individual scalar variables and focuses on core functionality without external dependencies.\nIncrements failed attempt counters and applies account lockout policies without constraint violations.\nReturns TRUE if processing succeeded, FALSE otherwise.",
        "LOGIN_AUTHENTICATION"
      ],
      [
        "auth",
        "process_valid_login",
        "IN p_login_attempt_hk bytea, OUT p_session_hk bytea, OUT p_user_hk bytea",
        null,
        "plpgsql",
        "\nDECLARE\n    v_user_hk BYTEA;\n    v_tenant_hk BYTEA;\n    v_session_bk VARCHAR(255);\n    v_session_hk BYTEA;\n    v_username VARCHAR(255);\n    v_ip_address INET;\n    v_user_agent TEXT;\n    v_token_value TEXT;\nBEGIN\n    -- Get validation status and user details\n    SELECT \n        uh.user_hk,\n        uh.tenant_hk,\n        sls.username,\n        sls.ip_address,\n        sls.user_agent\n    INTO \n        v_user_hk,\n        v_tenant_hk,\n        v_username,\n        v_ip_address,\n        v_user_agent\n    FROM staging.login_status_s sls\n    JOIN staging.login_attempt_h slh ON sls.login_attempt_hk = slh.login_attempt_hk\n    JOIN auth.user_auth_s uas ON sls.username = uas.username\n    JOIN auth.user_h uh ON uas.user_hk = uh.user_hk\n    WHERE sls.login_attempt_hk = p_login_attempt_hk\n    AND sls.validation_status = 'VALID'\n    AND sls.load_date = (\n        SELECT MAX(load_date)\n        FROM staging.login_status_s\n        WHERE login_attempt_hk = p_login_attempt_hk\n    )\n    AND uas.load_date = (\n        SELECT MAX(load_date)\n        FROM auth.user_auth_s\n        WHERE user_hk = uh.user_hk\n        AND load_end_date IS NULL\n    );\n\n    IF v_user_hk IS NULL THEN\n        p_session_hk := NULL;\n        p_user_hk := NULL;\n        RETURN;\n    END IF;\n\n    -- Generate session identifiers\n    v_session_bk := encode(v_tenant_hk, 'hex') || '_SESSION_' || \n                   encode(v_user_hk, 'hex') || '_' ||\n                   to_char(CURRENT_TIMESTAMP, 'YYYYMMDD_HH24MISS');\n    v_session_hk := util.hash_binary(v_session_bk);\n\n    -- Create session hub record\n    INSERT INTO auth.session_h (\n        session_hk,\n        session_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        v_session_hk,\n        v_session_bk,\n        v_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    );\n\n    -- Create session state satellite\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    ) VALUES (\n        v_session_hk,\n        util.current_load_date(),\n        util.hash_binary(v_session_bk || 'ACTIVE'),\n        CURRENT_TIMESTAMP,\n        v_ip_address,\n        v_user_agent,\n        jsonb_build_object('login_attempt_hk', encode(p_login_attempt_hk, 'hex')),\n        'ACTIVE',\n        CURRENT_TIMESTAMP,\n        util.get_record_source()\n    );\n\n    -- Create user-session link\n    INSERT INTO auth.user_session_l (\n        link_user_session_hk,\n        user_hk,\n        session_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(v_user_hk::text || v_session_hk::text),\n        v_user_hk,\n        v_session_hk,\n        v_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    );\n\n    -- Generate API token for session (store in session_bk for easy retrieval)\n    v_token_value := encode(gen_random_bytes(32), 'hex');\n    \n    -- Update session record with token as business key\n    UPDATE auth.session_h\n    SET session_bk = v_token_value\n    WHERE session_hk = v_session_hk;\n\n    -- Set output parameters\n    p_session_hk := v_session_hk;\n    p_user_hk := v_user_hk;\nEND;\n",
        null,
        "LOGIN_AUTHENTICATION"
      ],
      [
        "auth",
        "process_valid_login_enhanced",
        "IN p_login_attempt_hk bytea, OUT p_session_hk bytea, OUT p_user_hk bytea",
        null,
        "plpgsql",
        "\nDECLARE\n    v_tenant_hk BYTEA;\n    v_user_hk BYTEA;\n    v_session_bk VARCHAR(255);\n    v_username VARCHAR(255);\n    v_ip_address INET;\n    v_user_agent TEXT;\n    v_validation_status VARCHAR(20);\n    v_security_policy RECORD;\n    v_api_token TEXT;\nBEGIN\n    -- Get validation status and related information\n    SELECT \n        slh.tenant_hk,\n        sls.validation_status,\n        sls.username,\n        sls.ip_address,\n        sls.user_agent\n    INTO \n        v_tenant_hk,\n        v_validation_status,\n        v_username,\n        v_ip_address,\n        v_user_agent\n    FROM staging.login_attempt_h slh\n    JOIN staging.login_status_s sls ON slh.login_attempt_hk = sls.login_attempt_hk\n    WHERE slh.login_attempt_hk = p_login_attempt_hk\n    AND sls.validation_status = 'VALID'\n    AND sls.load_end_date IS NULL\n    ORDER BY sls.load_date DESC\n    LIMIT 1;\n\n    -- Only proceed if login is valid\n    IF v_validation_status = 'VALID' THEN\n        -- Get user details\n        SELECT uh.user_hk INTO v_user_hk\n        FROM auth.user_h uh\n        JOIN auth.user_auth_s uas ON uh.user_hk = uas.user_hk\n        WHERE uh.tenant_hk = v_tenant_hk\n        AND uas.username = v_username\n        AND uas.load_end_date IS NULL\n        ORDER BY uas.load_date DESC\n        LIMIT 1;\n\n        -- Check if account should be locked\n        IF auth.check_account_lockout(v_tenant_hk, v_user_hk) THEN\n            -- Lock the account by creating new auth satellite record\n            INSERT INTO auth.user_auth_s (\n                user_hk,\n                load_date,\n                hash_diff,\n                username,\n                password_hash,\n                password_salt,\n                last_login_date,\n                password_last_changed,\n                failed_login_attempts,\n                account_locked,\n                account_locked_until,\n                must_change_password,\n                record_source\n            )\n            SELECT \n                user_hk,\n                util.current_load_date(),\n                util.hash_binary(username || 'LOCKED' || CURRENT_TIMESTAMP::text),\n                username,\n                password_hash,\n                password_salt,\n                last_login_date,\n                password_last_changed,\n                COALESCE(failed_login_attempts, 0) + 1,\n                TRUE, -- account_locked\n                CURRENT_TIMESTAMP + INTERVAL '30 minutes', -- account_locked_until\n                must_change_password,\n                util.get_record_source()\n            FROM auth.user_auth_s\n            WHERE user_hk = v_user_hk\n            AND load_end_date IS NULL\n            ORDER BY load_date DESC\n            LIMIT 1;\n\n            -- End-date the previous record\n            UPDATE auth.user_auth_s\n            SET load_end_date = util.current_load_date()\n            WHERE user_hk = v_user_hk\n            AND load_end_date IS NULL\n            AND load_date < util.current_load_date();\n\n            -- Return null values to indicate failed login due to lockout\n            p_session_hk := NULL;\n            p_user_hk := NULL;\n            RETURN;\n        END IF;\n\n        -- Get security policy for session creation\n        SELECT \n            sp.session_timeout_minutes,\n            sp.require_mfa,\n            COALESCE(sp.session_absolute_timeout_hours, 12) as session_absolute_timeout_hours\n        INTO v_security_policy\n        FROM auth.security_policy_s sp\n        JOIN auth.security_policy_h hp ON sp.security_policy_hk = hp.security_policy_hk\n        WHERE hp.tenant_hk = v_tenant_hk\n        AND sp.is_active = TRUE\n        AND sp.load_end_date IS NULL\n        ORDER BY sp.load_date DESC\n        LIMIT 1;\n\n        -- Generate session identifiers\n        v_session_bk := 'SESSION_' || encode(v_tenant_hk, 'hex') || '_' || \n                       encode(v_user_hk, 'hex') || '_' || \n                       to_char(CURRENT_TIMESTAMP, 'YYYYMMDD_HH24MISS');\n        p_session_hk := util.hash_binary(v_session_bk);\n\n        -- Create session hub record\n        INSERT INTO auth.session_h (\n            session_hk,\n            session_bk,\n            tenant_hk,\n            load_date,\n            record_source\n        ) VALUES (\n            p_session_hk,\n            v_session_bk,\n            v_tenant_hk,\n            util.current_load_date(),\n            util.get_record_source()\n        );\n\n        -- Create session state satellite record\n        INSERT INTO auth.session_state_s (\n            session_hk,\n            load_date,\n            hash_diff,\n            session_start,\n            session_end,\n            ip_address,\n            user_agent,\n            session_data,\n            session_status,\n            last_activity,\n            record_source\n        ) VALUES (\n            p_session_hk,\n            util.current_load_date(),\n            util.hash_binary(v_session_bk || 'ACTIVE' || COALESCE(v_ip_address::text, 'UNKNOWN')),\n            CURRENT_TIMESTAMP,\n            NULL, -- session_end\n            v_ip_address,\n            v_user_agent,\n            jsonb_build_object(\n                'require_mfa', COALESCE(v_security_policy.require_mfa, false),\n                'timeout_minutes', COALESCE(v_security_policy.session_timeout_minutes, 60)\n            ),\n            'ACTIVE',\n            CURRENT_TIMESTAMP,\n            util.get_record_source()\n        );\n\n        -- Create user-session link\n        INSERT INTO auth.user_session_l (\n            link_user_session_hk,\n            user_hk,\n            session_hk,\n            tenant_hk,\n            load_date,\n            record_source\n        ) VALUES (\n            util.hash_binary(v_user_hk::text || p_session_hk::text),\n            v_user_hk,\n            p_session_hk,\n            v_tenant_hk,\n            util.current_load_date(),\n            util.get_record_source()\n        );\n\n        -- Update user's last login and reset failed attempts\n        INSERT INTO auth.user_auth_s (\n            user_hk,\n            load_date,\n            hash_diff,\n            username,\n            password_hash,\n            password_salt,\n            last_login_date,\n            password_last_changed,\n            failed_login_attempts,\n            account_locked,\n            account_locked_until,\n            must_change_password,\n            record_source\n        )\n        SELECT \n            user_hk,\n            util.current_load_date(),\n            util.hash_binary(username || 'LOGIN_SUCCESS' || CURRENT_TIMESTAMP::text),\n            username,\n            password_hash,\n            password_salt,\n            CURRENT_TIMESTAMP, -- last_login_date\n            password_last_changed,\n            0, -- Reset failed_login_attempts\n            FALSE, -- account_locked\n            NULL, -- account_locked_until\n            must_change_password,\n            util.get_record_source()\n        FROM auth.user_auth_s\n        WHERE user_hk = v_user_hk\n        AND load_end_date IS NULL\n        ORDER BY load_date DESC\n        LIMIT 1;\n\n        -- End-date the previous auth record\n        UPDATE auth.user_auth_s\n        SET load_end_date = util.current_load_date()\n        WHERE user_hk = v_user_hk\n        AND load_end_date IS NULL\n        AND load_date < util.current_load_date();\n\n        -- Generate API token for the session if the procedure exists\n        BEGIN\n            CALL auth.generate_token_for_session(p_session_hk, v_api_token);\n            \n            -- Update session business key to include token reference\n            UPDATE auth.session_h\n            SET session_bk = v_api_token\n            WHERE session_hk = p_session_hk;\n        EXCEPTION WHEN OTHERS THEN\n            -- If token generation fails, continue without it\n            RAISE NOTICE 'Token generation skipped: %', SQLERRM;\n        END;\n\n        -- Set output parameters\n        p_user_hk := v_user_hk;\n\n    ELSE\n        -- Invalid login attempt\n        p_session_hk := NULL;\n        p_user_hk := NULL;\n    END IF;\nEND;\n",
        null,
        "LOGIN_AUTHENTICATION"
      ],
      [
        "auth",
        "check_account_lockout",
        "p_tenant_hk bytea, p_user_hk bytea",
        "boolean",
        "plpgsql",
        "\nDECLARE\n    v_failed_attempts INTEGER;\n    v_lockout_threshold INTEGER;\n    v_lockout_duration INTEGER;\n    v_username VARCHAR(100);\n    v_last_lockout_time TIMESTAMP WITH TIME ZONE;\nBEGIN\n    -- Get username for this user\n    SELECT username INTO v_username\n    FROM auth.user_auth_s\n    WHERE user_hk = p_user_hk\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    -- Get security policy settings for the tenant\n    SELECT \n        sp.account_lockout_threshold,\n        sp.account_lockout_duration_minutes\n    INTO \n        v_lockout_threshold,\n        v_lockout_duration\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h hp ON sp.security_policy_hk = hp.security_policy_hk\n    WHERE hp.tenant_hk = p_tenant_hk\n    AND sp.is_active = TRUE\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n\n    -- Get the last lockout time for this user\n    SELECT account_locked_until INTO v_last_lockout_time\n    FROM auth.user_auth_s\n    WHERE user_hk = p_user_hk\n    AND account_locked = TRUE\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    -- If account is currently locked, check if lockout period has expired\n    IF v_last_lockout_time IS NOT NULL AND \n       v_last_lockout_time > CURRENT_TIMESTAMP THEN\n        RETURN TRUE; -- Account is still locked\n    END IF;\n\n    -- Count recent failed login attempts from staging login status\n    -- Note: Using the table names with new naming convention\n    SELECT COUNT(*) INTO v_failed_attempts\n    FROM staging.login_status_s sls\n    JOIN staging.login_attempt_h slh ON sls.login_attempt_hk = slh.login_attempt_hk\n    WHERE slh.tenant_hk = p_tenant_hk\n    AND sls.username = v_username\n    AND sls.validation_status IN ('INVALID_PASSWORD', 'INVALID_USER')\n    AND sls.attempt_timestamp > CURRENT_TIMESTAMP - (COALESCE(v_lockout_duration, 30) || ' minutes')::INTERVAL\n    AND sls.load_end_date IS NULL;\n\n    -- Return true if failed attempts exceed threshold\n    RETURN v_failed_attempts >= COALESCE(v_lockout_threshold, 5);\nEND;\n",
        null,
        "OTHER_AUTH"
      ],
      [
        "auth",
        "check_rate_limit_enhanced",
        "p_tenant_hk bytea, p_ip_address inet, p_endpoint_path character varying, p_user_agent text DEFAULT NULL::text",
        "TABLE(is_allowed boolean, wait_time_seconds integer, reason text, compliance_alert boolean)",
        "plpgsql",
        "\nDECLARE\n    v_tracking_hk BYTEA;\n    v_tracking_bk VARCHAR(255);\n    v_request_count INTEGER;\n    v_time_window INTERVAL;\n    v_max_requests INTEGER;\n    v_user_agent_hash BYTEA;\n    v_is_suspicious BOOLEAN := false;\n    v_compliance_threshold INTEGER := 100;\nBEGIN\n    v_user_agent_hash := CASE \n        WHEN p_user_agent IS NOT NULL \n        THEN util.hash_binary(p_user_agent)\n        ELSE NULL \n    END;\n\n    SELECT \n        INTERVAL '1 minute' * COALESCE(sp.session_timeout_minutes, 15),\n        COALESCE(sp.account_lockout_threshold * 10, 50)\n    INTO \n        v_time_window,\n        v_max_requests\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h hp ON sp.security_policy_hk = hp.security_policy_hk\n    WHERE hp.tenant_hk = p_tenant_hk\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n\n    v_time_window := COALESCE(v_time_window, INTERVAL '15 minutes');\n    v_max_requests := COALESCE(v_max_requests, 50);\n\n    v_tracking_bk := encode(p_tenant_hk, 'hex') || '_IP_' || \n                     encode(digest(p_ip_address::text, 'sha256'), 'hex');\n    v_tracking_hk := util.hash_binary(v_tracking_bk);\n\n    INSERT INTO auth.security_tracking_h (\n        security_tracking_hk,\n        security_tracking_bk,\n        tenant_hk\n    ) VALUES (\n        v_tracking_hk,\n        v_tracking_bk,\n        p_tenant_hk\n    ) ON CONFLICT (security_tracking_hk) DO NOTHING;\n\n    SELECT \n        request_count,\n        CASE \n            WHEN request_count > (v_max_requests * 0.8) THEN true\n            WHEN first_request_time > CURRENT_TIMESTAMP - INTERVAL '1 minute' \n                 AND request_count > 10 THEN true\n            ELSE false\n        END\n    INTO v_request_count, v_is_suspicious\n    FROM auth.ip_tracking_s\n    WHERE security_tracking_hk = v_tracking_hk\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    INSERT INTO auth.ip_tracking_s (\n        security_tracking_hk,\n        hash_diff,\n        ip_address,\n        request_count,\n        first_request_time,\n        last_request_time,\n        is_blocked,\n        suspicious_activity_flag,\n        suspicious_activity_details,\n        endpoint_accessed,\n        user_agent_hash\n    )\n    SELECT\n        v_tracking_hk,\n        util.hash_binary(p_ip_address::text || CURRENT_TIMESTAMP::text || p_endpoint_path),\n        p_ip_address,\n        CASE \n            WHEN its.first_request_time < CURRENT_TIMESTAMP - v_time_window OR its.first_request_time IS NULL\n            THEN 1\n            ELSE COALESCE(its.request_count, 0) + 1\n        END,\n        CASE \n            WHEN its.first_request_time < CURRENT_TIMESTAMP - v_time_window OR its.first_request_time IS NULL\n            THEN CURRENT_TIMESTAMP\n            ELSE COALESCE(its.first_request_time, CURRENT_TIMESTAMP)\n        END,\n        CURRENT_TIMESTAMP,\n        CASE \n            WHEN COALESCE(its.request_count, 0) + 1 > v_max_requests THEN true\n            ELSE false\n        END,\n        v_is_suspicious,\n        jsonb_build_object(\n            'endpoint_path', p_endpoint_path,\n            'request_time', CURRENT_TIMESTAMP,\n            'user_agent_provided', (p_user_agent IS NOT NULL),\n            'rate_limit_threshold', v_max_requests\n        ),\n        p_endpoint_path,\n        v_user_agent_hash\n    FROM (\n        SELECT * FROM auth.ip_tracking_s \n        WHERE security_tracking_hk = v_tracking_hk \n        AND load_end_date IS NULL\n        ORDER BY load_date DESC \n        LIMIT 1\n    ) its;\n\n    SELECT request_count INTO v_request_count\n    FROM auth.ip_tracking_s\n    WHERE security_tracking_hk = v_tracking_hk\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    RETURN QUERY \n    SELECT \n        CASE\n            WHEN its.is_blocked THEN FALSE\n            WHEN COALESCE(v_request_count, 0) <= v_max_requests THEN TRUE\n            ELSE FALSE\n        END,\n        GREATEST(0, EXTRACT(EPOCH FROM (\n            (its.first_request_time + v_time_window) - CURRENT_TIMESTAMP\n        ))::INTEGER),\n        CASE\n            WHEN its.is_blocked THEN 'IP address blocked due to excessive requests'\n            WHEN COALESCE(v_request_count, 0) > v_max_requests THEN 'Rate limit exceeded for time window'\n            ELSE 'Request allowed within rate limits'\n        END,\n        CASE \n            WHEN COALESCE(v_request_count, 0) > v_compliance_threshold THEN TRUE\n            WHEN v_is_suspicious THEN TRUE\n            ELSE FALSE\n        END\n    FROM auth.ip_tracking_s its\n    WHERE its.security_tracking_hk = v_tracking_hk\n    AND its.load_end_date IS NULL\n    ORDER BY its.load_date DESC\n    LIMIT 1;\nEND;\n",
        "Enhanced rate limiting with HIPAA compliance monitoring and suspicious activity detection",
        "OTHER_AUTH"
      ],
      [
        "auth",
        "get_cached_user_auth",
        "p_username character varying, p_tenant_hk bytea",
        "TABLE(user_hk bytea, password_hash bytea, password_salt bytea, account_locked boolean, account_locked_until timestamp with time zone, failed_login_attempts integer, last_login_date timestamp with time zone)",
        "plpgsql",
        "\nBEGIN\n    RETURN QUERY\n    SELECT \n        muac.user_hk,\n        muac.password_hash,\n        muac.password_salt,\n        muac.account_locked,\n        muac.account_locked_until,\n        muac.failed_login_attempts,\n        muac.last_login_date\n    FROM auth.mv_user_authentication_cache muac\n    WHERE muac.username = p_username\n    AND muac.tenant_hk = p_tenant_hk\n    AND muac.rn = 1;\nEND;\n",
        null,
        "OTHER_AUTH"
      ],
      [
        "auth",
        "get_tenant_definition",
        "p_tenant_hk bytea",
        "TABLE(tenant_hk bytea, tenant_name character varying, tenant_display_name character varying, tenant_status character varying, subscription_level character varying, max_users integer, compliance_level character varying, tenant_settings jsonb, feature_flags jsonb)",
        "plpgsql",
        "\nBEGIN\n    RETURN QUERY\n    SELECT \n        tds.tenant_hk,\n        tds.tenant_name,\n        tds.tenant_display_name,\n        tds.tenant_status,\n        tds.subscription_level,\n        tds.max_users,\n        tds.compliance_level,\n        tds.tenant_settings,\n        tds.feature_flags\n    FROM auth.tenant_definition_s tds\n    WHERE tds.tenant_hk = p_tenant_hk\n    AND tds.load_end_date IS NULL\n    ORDER BY tds.load_date DESC\n    LIMIT 1;\nEND;\n",
        null,
        "OTHER_AUTH"
      ],
      [
        "auth",
        "get_user_salt",
        "p_email character varying, p_tenant_hk bytea",
        "bytea",
        "plpgsql",
        "\nDECLARE\n    v_salt BYTEA;\nBEGIN\n    -- Updated with corrected table names and field name\n    SELECT password_salt INTO v_salt\n    FROM auth.user_auth_s sua\n    JOIN auth.user_h hu ON sua.user_hk = hu.user_hk\n    WHERE sua.username = p_email  -- Assuming username is email\n    AND hu.tenant_hk = p_tenant_hk\n    AND sua.load_end_date IS NULL\n    ORDER BY sua.load_date DESC\n    LIMIT 1;\n    \n    RETURN v_salt;\nEND;\n",
        null,
        "OTHER_AUTH"
      ],
      [
        "auth",
        "rollback_step_13",
        "",
        null,
        "plpgsql",
        "\nBEGIN\n    -- Drop functions and procedures created in this step\n    DROP FUNCTION IF EXISTS auth.check_account_lockout(BYTEA, BYTEA);\n    DROP PROCEDURE IF EXISTS auth.process_valid_login_enhanced(BYTEA, BYTEA, BYTEA);\n    DROP FUNCTION IF EXISTS auth.process_failed_login(BYTEA, VARCHAR, VARCHAR, INET);\n    DROP PROCEDURE IF EXISTS auth.maintain_security_state();\n    DROP FUNCTION IF EXISTS auth.validate_session_enhanced(BYTEA, INET, TEXT);\n    \n    -- Drop indexes created in this step (ignore errors if they don't exist)\n    DROP INDEX IF EXISTS auth.idx_user_auth_s_failed_attempts;\n    DROP INDEX IF EXISTS auth.idx_user_auth_s_account_locked_step13;\n    DROP INDEX IF EXISTS auth.idx_session_state_s_last_activity_step13;\n    DROP INDEX IF EXISTS auth.idx_session_state_s_session_start;\n    DROP INDEX IF EXISTS auth.idx_login_status_s_username_validation;\n    \n    RAISE NOTICE 'Step 13 rollback completed successfully';\nEND;\n",
        "Rollback procedure for Step 13 implementation - removes all functions, procedures, and indexes created in this step",
        "OTHER_AUTH"
      ],
      [
        "auth",
        "update_tenant_definition",
        "p_tenant_hk bytea, p_tenant_name character varying DEFAULT NULL::character varying, p_tenant_display_name character varying DEFAULT NULL::character varying, p_tenant_status character varying DEFAULT NULL::character varying, p_subscription_level character varying DEFAULT NULL::character varying, p_max_users integer DEFAULT NULL::integer, p_compliance_level character varying DEFAULT NULL::character varying, p_tenant_settings jsonb DEFAULT NULL::jsonb, p_feature_flags jsonb DEFAULT NULL::jsonb",
        "boolean",
        "plpgsql",
        "\nDECLARE\n    v_current_record RECORD;\n    v_new_hash_diff BYTEA;\n    v_changes_detected BOOLEAN := FALSE;\nBEGIN\n    -- Get current record\n    SELECT * INTO v_current_record\n    FROM auth.tenant_definition_s\n    WHERE tenant_hk = p_tenant_hk\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Tenant definition not found for tenant_hk: %', encode(p_tenant_hk, 'hex');\n    END IF;\n    \n    -- Calculate new hash to detect changes\n    v_new_hash_diff := util.hash_binary(\n        COALESCE(p_tenant_name, v_current_record.tenant_name) ||\n        COALESCE(p_tenant_display_name, v_current_record.tenant_display_name) ||\n        COALESCE(p_tenant_status, v_current_record.tenant_status) ||\n        COALESCE(p_subscription_level, v_current_record.subscription_level) ||\n        COALESCE(p_max_users, v_current_record.max_users)::text ||\n        COALESCE(p_compliance_level, v_current_record.compliance_level) ||\n        COALESCE(p_tenant_settings, v_current_record.tenant_settings)::text ||\n        COALESCE(p_feature_flags, v_current_record.feature_flags)::text ||\n        CURRENT_TIMESTAMP::text\n    );\n    \n    -- Check if changes were made\n    IF v_new_hash_diff != v_current_record.hash_diff THEN\n        v_changes_detected := TRUE;\n        \n        -- End-date the current record\n        UPDATE auth.tenant_definition_s\n        SET load_end_date = util.current_load_date()\n        WHERE tenant_hk = p_tenant_hk\n        AND load_end_date IS NULL;\n        \n        -- Insert new record with changes\n        INSERT INTO auth.tenant_definition_s (\n            tenant_hk, hash_diff, record_source,\n            tenant_name, tenant_display_name, tenant_status,\n            subscription_level, max_users, compliance_level,\n            tenant_settings, feature_flags,\n            contact_email, contact_phone, contact_address,\n            subscription_start_date, subscription_end_date,\n            max_storage_gb, data_retention_days, encryption_required,\n            last_updated_by, last_updated_date\n        ) VALUES (\n            p_tenant_hk, v_new_hash_diff, util.get_record_source(),\n            COALESCE(p_tenant_name, v_current_record.tenant_name),\n            COALESCE(p_tenant_display_name, v_current_record.tenant_display_name),\n            COALESCE(p_tenant_status, v_current_record.tenant_status),\n            COALESCE(p_subscription_level, v_current_record.subscription_level),\n            COALESCE(p_max_users, v_current_record.max_users),\n            COALESCE(p_compliance_level, v_current_record.compliance_level),\n            COALESCE(p_tenant_settings, v_current_record.tenant_settings),\n            COALESCE(p_feature_flags, v_current_record.feature_flags),\n            v_current_record.contact_email,\n            v_current_record.contact_phone,\n            v_current_record.contact_address,\n            v_current_record.subscription_start_date,\n            v_current_record.subscription_end_date,\n            v_current_record.max_storage_gb,\n            v_current_record.data_retention_days,\n            v_current_record.encryption_required,\n            SESSION_USER,\n            CURRENT_TIMESTAMP\n        );\n    END IF;\n    \n    RETURN v_changes_detected;\nEND;\n",
        null,
        "OTHER_AUTH"
      ],
      [
        "auth",
        "verify_step_13_implementation",
        "",
        null,
        "plpgsql",
        "\nDECLARE\n    v_function_count INTEGER;\n    v_index_count INTEGER;\n    v_trigger_count INTEGER;\nBEGIN\n    -- Count functions and procedures created\n    SELECT COUNT(*) INTO v_function_count\n    FROM information_schema.routines\n    WHERE routine_schema = 'auth'\n    AND routine_name IN (\n        'check_account_lockout',\n        'process_valid_login_enhanced',\n        'process_failed_login',\n        'maintain_security_state',\n        'validate_session_enhanced'\n    );\n\n    -- Count indexes created\n    SELECT COUNT(*) INTO v_index_count\n    FROM pg_indexes\n    WHERE schemaname IN ('auth', 'staging')\n    AND indexname LIKE '%_step13';\n\n    -- Count audit triggers\n    SELECT COUNT(*) INTO v_trigger_count\n    FROM information_schema.triggers\n    WHERE trigger_schema IN ('auth', 'staging')\n    AND trigger_name LIKE 'trg_audit_%';\n\n    RAISE NOTICE 'Step 13 Verification Results:';\n    RAISE NOTICE 'Functions/Procedures: % (expected: 5)', v_function_count;\n    RAISE NOTICE 'Indexes: % (expected: 5)', v_index_count;\n    RAISE NOTICE 'Audit Triggers: % (varies by table count)', v_trigger_count;\n    \n    IF v_function_count = 5 THEN\n        RAISE NOTICE 'Step 13 implementation appears successful!';\n    ELSE\n        RAISE NOTICE 'Step 13 implementation may have issues - please review';\n    END IF;\nEND;\n",
        "Verification procedure that checks if all Step 13 components were successfully installed",
        "OTHER_AUTH"
      ],
      [
        "auth",
        "change_password",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        "\nDECLARE\n    v_user_hk BYTEA;\n    v_tenant_hk BYTEA;\n    v_username VARCHAR(255);\n    v_current_password TEXT;\n    v_new_password TEXT;\n    v_user_auth RECORD;\n    v_salt TEXT;\n    v_password_hash TEXT;\n    v_load_date TIMESTAMP WITH TIME ZONE;\n    v_record_source VARCHAR(100);\n    v_credentials_valid BOOLEAN := FALSE;\n    v_stored_hash TEXT;\nBEGIN\n    -- Extract parameters from JSON request\n    v_username := p_request->>'username';\n    v_current_password := p_request->>'current_password';\n    v_new_password := p_request->>'new_password';\n    \n    -- Initialize operational variables\n    v_load_date := util.current_load_date();\n    v_record_source := util.get_record_source();\n    \n    -- Validate required parameters\n    IF v_username IS NULL OR v_current_password IS NULL OR v_new_password IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Username, current password, and new password are required',\n            'error_code', 'MISSING_PARAMETERS'\n        );\n    END IF;\n    \n    -- Basic password strength validation\n    IF LENGTH(v_new_password) < 8 THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'New password must be at least 8 characters long',\n            'error_code', 'PASSWORD_TOO_SHORT'\n        );\n    END IF;\n    \n    -- Get current user authentication data\n    SELECT \n        uh.user_hk,\n        uh.tenant_hk,\n        uas.password_hash,\n        uas.username,\n        uas.account_locked\n    INTO v_user_auth\n    FROM auth.user_h uh\n    JOIN auth.user_auth_s uas ON uh.user_hk = uas.user_hk\n    WHERE uas.username = v_username\n    AND uas.load_end_date IS NULL\n    ORDER BY uas.load_date DESC\n    LIMIT 1;\n    \n    -- Check if user exists\n    IF v_user_auth.user_hk IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'User not found',\n            'error_code', 'USER_NOT_FOUND'\n        );\n    END IF;\n    \n    -- Check if account is locked\n    IF v_user_auth.account_locked THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Account is locked - cannot change password',\n            'error_code', 'ACCOUNT_LOCKED'\n        );\n    END IF;\n    \n    -- Validate current password using WORKING METHOD\n    IF v_user_auth.password_hash IS NOT NULL THEN\n        BEGIN\n            -- Use convert_from method that works\n            v_stored_hash := convert_from(v_user_auth.password_hash, 'UTF8');\n            -- Verify we have a valid bcrypt hash\n            IF v_stored_hash LIKE '$2%$%$%' THEN\n                v_credentials_valid := (crypt(v_current_password, v_stored_hash) = v_stored_hash);\n            ELSE\n                v_credentials_valid := FALSE;\n            END IF;\n        EXCEPTION WHEN OTHERS THEN\n            v_credentials_valid := FALSE;\n        END;\n    ELSE\n        v_credentials_valid := FALSE;\n    END IF;\n    \n    IF NOT v_credentials_valid THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Current password is incorrect',\n            'error_code', 'INVALID_CURRENT_PASSWORD'\n        );\n    END IF;\n    \n    -- Set context variables\n    v_user_hk := v_user_auth.user_hk;\n    v_tenant_hk := v_user_auth.tenant_hk;\n    \n    -- Generate new password hash\n    v_salt := gen_salt('bf', 8);\n    v_password_hash := crypt(v_new_password, v_salt);\n    \n    -- End-date the previous record FIRST to avoid unique constraint violation\n    UPDATE auth.user_auth_s\n    SET load_end_date = v_load_date\n    WHERE user_hk = v_user_hk\n    AND load_end_date IS NULL;\n    \n    -- Create new auth satellite record with updated password using WORKING METHOD\n    INSERT INTO auth.user_auth_s (\n        user_hk,\n        load_date,\n        hash_diff,\n        username,\n        password_hash,\n        password_salt,\n        last_login_date,\n        password_last_changed,\n        failed_login_attempts,\n        account_locked,\n        account_locked_until,\n        must_change_password,\n        record_source\n    )\n    SELECT \n        user_hk,\n        v_load_date,\n        util.hash_binary(username || 'PASSWORD_CHANGE' || v_load_date::text),\n        username,\n        convert_to(v_password_hash, 'UTF8'), -- FIXED: Use convert_to instead of ::BYTEA\n        convert_to(v_salt, 'UTF8'), -- FIXED: Use convert_to instead of ::BYTEA\n        last_login_date,\n        v_load_date, -- Update password_last_changed\n        0, -- Reset failed attempts on password change\n        FALSE, -- Unlock account\n        NULL, -- Clear lockout time\n        FALSE, -- Clear must_change_password flag\n        v_record_source\n    FROM auth.user_auth_s\n    WHERE user_hk = v_user_hk\n    AND load_end_date = v_load_date  -- Use the record we just end-dated\n    ORDER BY load_date DESC\n    LIMIT 1;\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'message', 'Password changed successfully',\n        'data', jsonb_build_object(\n            'password_changed_date', v_load_date,\n            'failed_attempts_reset', true\n        )\n    );\n    \nEXCEPTION WHEN OTHERS THEN\n    RETURN jsonb_build_object(\n        'success', false,\n        'message', 'An error occurred while changing password',\n        'error_code', 'PASSWORD_CHANGE_ERROR',\n        'debug_info', jsonb_build_object(\n            'error', SQLERRM,\n            'sqlstate', SQLSTATE\n        )\n    );\nEND;\n",
        null,
        "PASSWORD_MANAGEMENT"
      ],
      [
        "auth",
        "reset_password",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        "\nDECLARE\n    v_target_user_hk BYTEA;\n    v_tenant_hk BYTEA;\n    v_admin_user_hk BYTEA;\n    v_target_username VARCHAR(255);\n    v_admin_username VARCHAR(255);\n    v_new_password TEXT;\n    v_generate_random BOOLEAN;\n    v_force_change BOOLEAN;\n    v_user_auth RECORD;\n    v_admin_auth RECORD;\n    v_salt TEXT;\n    v_password_hash TEXT;\n    v_load_date TIMESTAMP WITH TIME ZONE;\n    v_record_source VARCHAR(100);\n    v_random_password TEXT;\nBEGIN\n    -- Extract parameters from JSON request\n    v_target_username := p_request->>'target_username';\n    v_admin_username := p_request->>'admin_username';\n    v_new_password := p_request->>'new_password';\n    v_generate_random := COALESCE((p_request->>'generate_random')::BOOLEAN, FALSE);\n    v_force_change := COALESCE((p_request->>'force_change')::BOOLEAN, TRUE);\n    \n    -- Initialize operational variables\n    v_load_date := util.current_load_date();\n    v_record_source := util.get_record_source();\n    \n    -- Validate required parameters\n    IF v_target_username IS NULL OR v_admin_username IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Target username and admin username are required',\n            'error_code', 'MISSING_PARAMETERS'\n        );\n    END IF;\n    \n    IF NOT v_generate_random AND v_new_password IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'New password is required when not generating random password',\n            'error_code', 'MISSING_NEW_PASSWORD'\n        );\n    END IF;\n    \n    -- Get target user information\n    SELECT \n        uh.user_hk,\n        uh.tenant_hk,\n        uas.username,\n        uas.account_locked\n    INTO v_user_auth\n    FROM auth.user_h uh\n    JOIN auth.user_auth_s uas ON uh.user_hk = uas.user_hk\n    WHERE uas.username = v_target_username\n    AND uas.load_end_date IS NULL\n    ORDER BY uas.load_date DESC\n    LIMIT 1;\n    \n    -- Check if target user exists\n    IF v_user_auth.user_hk IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Target user not found',\n            'error_code', 'USER_NOT_FOUND'\n        );\n    END IF;\n    \n    -- Set context variables\n    v_target_user_hk := v_user_auth.user_hk;\n    v_tenant_hk := v_user_auth.tenant_hk;\n    \n    -- Get admin user information (must be from same tenant)\n    SELECT \n        uh.user_hk,\n        uas.username\n    INTO v_admin_auth\n    FROM auth.user_h uh\n    JOIN auth.user_auth_s uas ON uh.user_hk = uas.user_hk\n    WHERE uas.username = v_admin_username\n    AND uh.tenant_hk = v_tenant_hk  -- Same tenant requirement\n    AND uas.load_end_date IS NULL\n    ORDER BY uas.load_date DESC\n    LIMIT 1;\n    \n    -- Check if admin user exists in same tenant\n    IF v_admin_auth.user_hk IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Admin user not found or not in same tenant',\n            'error_code', 'ADMIN_NOT_FOUND'\n        );\n    END IF;\n    \n    v_admin_user_hk := v_admin_auth.user_hk;\n    \n    -- TODO: Add role-based authorization check here\n    -- Verify admin has permission to reset passwords\n    \n    -- Generate or use provided password\n    IF v_generate_random THEN\n        -- Generate secure random password\n        v_random_password := encode(gen_random_bytes(12), 'base64');\n        -- Clean up the base64 to make it more user-friendly\n        v_random_password := REPLACE(REPLACE(REPLACE(v_random_password, '/', '9'), '+', '8'), '=', '7');\n        v_new_password := v_random_password;\n    END IF;\n    \n    -- Basic password strength validation\n    IF LENGTH(v_new_password) < 8 THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'New password must be at least 8 characters long',\n            'error_code', 'PASSWORD_TOO_SHORT'\n        );\n    END IF;\n    \n    -- Generate new password hash\n    v_salt := gen_salt('bf', 8);\n    v_password_hash := crypt(v_new_password, v_salt);\n    \n    -- End-date the previous record FIRST to avoid unique constraint violation\n    UPDATE auth.user_auth_s\n    SET load_end_date = v_load_date\n    WHERE user_hk = v_target_user_hk\n    AND load_end_date IS NULL;\n    \n    -- Create new auth satellite record with reset password using WORKING METHOD\n    INSERT INTO auth.user_auth_s (\n        user_hk,\n        load_date,\n        hash_diff,\n        username,\n        password_hash,\n        password_salt,\n        last_login_date,\n        password_last_changed,\n        failed_login_attempts,\n        account_locked,\n        account_locked_until,\n        must_change_password,\n        record_source\n    )\n    SELECT \n        user_hk,\n        v_load_date,\n        util.hash_binary(username || 'PASSWORD_RESET_BY_ADMIN' || v_load_date::text),\n        username,\n        convert_to(v_password_hash, 'UTF8'), -- FIXED: Use convert_to instead of ::BYTEA\n        convert_to(v_salt, 'UTF8'), -- FIXED: Use convert_to instead of ::BYTEA\n        last_login_date,\n        v_load_date, -- Update password_last_changed\n        0, -- Reset failed attempts\n        FALSE, -- Unlock account\n        NULL, -- Clear lockout time\n        v_force_change, -- Force change on next login if requested\n        v_record_source || '_ADMIN_RESET'\n    FROM auth.user_auth_s\n    WHERE user_hk = v_target_user_hk\n    AND load_end_date = v_load_date  -- Use the record we just end-dated\n    ORDER BY load_date DESC\n    LIMIT 1;\n    \n    -- Create audit record for password reset (if audit schema exists)\n    BEGIN\n        INSERT INTO audit.audit_event_h (\n            audit_event_hk,\n            audit_event_bk,\n            tenant_hk,\n            load_date,\n            record_source\n        ) VALUES (\n            util.hash_binary('PASSWORD_RESET_' || v_target_username || '_' || v_load_date::text),\n            'PASSWORD_RESET_' || v_target_username || '_' || v_load_date::text,\n            v_tenant_hk,\n            v_load_date,\n            v_record_source\n        );\n        \n        -- Create detailed audit record\n        INSERT INTO audit.audit_detail_s (\n            audit_event_hk,\n            load_date,\n            hash_diff,\n            table_name,\n            operation,\n            changed_by,\n            old_data,\n            new_data\n        ) VALUES (\n            util.hash_binary('PASSWORD_RESET_' || v_target_username || '_' || v_load_date::text),\n            v_load_date,\n            util.hash_binary('PASSWORD_RESET_AUDIT' || v_load_date::text),\n            'auth.user_auth_s',\n            'PWD_RESET',\n            v_admin_username,\n            jsonb_build_object(\n                'target_user', v_target_username,\n                'action', 'password_reset'\n            ),\n            jsonb_build_object(\n                'target_user', v_target_username,\n                'admin_user', v_admin_username,\n                'force_change_on_login', v_force_change,\n                'password_generated', v_generate_random,\n                'reset_timestamp', v_load_date\n            )\n        );\n    EXCEPTION WHEN OTHERS THEN\n        -- Ignore audit errors for now - password reset still succeeds\n        NULL;\n    END;\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'message', 'Password reset successfully',\n        'data', jsonb_build_object(\n            'target_user', v_target_username,\n            'password_reset_date', v_load_date,\n            'must_change_password', v_force_change,\n            'failed_attempts_reset', true,\n            'account_unlocked', true,\n            'new_password', CASE WHEN v_generate_random THEN v_new_password ELSE '[HIDDEN]' END\n        )\n    );\n    \nEXCEPTION WHEN OTHERS THEN\n    RETURN jsonb_build_object(\n        'success', false,\n        'message', 'An error occurred while resetting password',\n        'error_code', 'PASSWORD_RESET_ERROR',\n        'debug_info', jsonb_build_object(\n            'error', SQLERRM,\n            'sqlstate', SQLSTATE\n        )\n    );\nEND;\n",
        null,
        "PASSWORD_MANAGEMENT"
      ],
      [
        "auth",
        "update_user_password_direct",
        "p_tenant_hk bytea, p_username character varying, p_new_password text, p_force_change boolean DEFAULT true",
        "jsonb",
        "plpgsql",
        "\nDECLARE\n    v_user_hk BYTEA;\n    v_salt TEXT;\n    v_password_hash TEXT;\n    v_load_date TIMESTAMP WITH TIME ZONE;\n    v_record_source VARCHAR(100);\nBEGIN\n    -- Initialize operational variables\n    v_load_date := util.current_load_date();\n    v_record_source := util.get_record_source() || '_DIRECT_UPDATE';\n    \n    -- Get user hash key\n    SELECT uh.user_hk INTO v_user_hk\n    FROM auth.user_h uh\n    JOIN auth.user_auth_s uas ON uh.user_hk = uas.user_hk\n    WHERE uh.tenant_hk = p_tenant_hk\n    AND uas.username = p_username\n    AND uas.load_end_date IS NULL\n    ORDER BY uas.load_date DESC\n    LIMIT 1;\n    \n    -- Check if user exists\n    IF v_user_hk IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'User not found',\n            'error_code', 'USER_NOT_FOUND'\n        );\n    END IF;\n    \n    -- Generate new password hash\n    v_salt := gen_salt('bf', 8);\n    v_password_hash := crypt(p_new_password, v_salt);\n    \n    -- End-date the previous record FIRST to avoid unique constraint violation\n    UPDATE auth.user_auth_s\n    SET load_end_date = v_load_date\n    WHERE user_hk = v_user_hk\n    AND load_end_date IS NULL;\n    \n    -- Create new auth satellite record using WORKING METHOD\n    INSERT INTO auth.user_auth_s (\n        user_hk,\n        load_date,\n        hash_diff,\n        username,\n        password_hash,\n        password_salt,\n        last_login_date,\n        password_last_changed,\n        failed_login_attempts,\n        account_locked,\n        account_locked_until,\n        must_change_password,\n        record_source\n    )\n    SELECT \n        user_hk,\n        v_load_date,\n        util.hash_binary(username || 'DIRECT_UPDATE' || v_load_date::text),\n        username,\n        convert_to(v_password_hash, 'UTF8'), -- FIXED: Use convert_to instead of ::BYTEA\n        convert_to(v_salt, 'UTF8'), -- FIXED: Use convert_to instead of ::BYTEA\n        last_login_date,\n        v_load_date,\n        0, -- Reset failed attempts\n        FALSE, -- Unlock account\n        NULL, -- Clear lockout time\n        p_force_change,\n        v_record_source\n    FROM auth.user_auth_s\n    WHERE user_hk = v_user_hk\n    AND load_end_date = v_load_date  -- Use the record we just end-dated\n    ORDER BY load_date DESC\n    LIMIT 1;\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'message', 'Password updated successfully',\n        'data', jsonb_build_object(\n            'username', p_username,\n            'password_updated_date', v_load_date,\n            'must_change_password', p_force_change\n        )\n    );\n    \nEXCEPTION WHEN OTHERS THEN\n    RETURN jsonb_build_object(\n        'success', false,\n        'message', 'An error occurred while updating password',\n        'error_code', 'PASSWORD_UPDATE_ERROR',\n        'debug_info', jsonb_build_object(\n            'error', SQLERRM,\n            'sqlstate', SQLSTATE\n        )\n    );\nEND;\n",
        null,
        "PASSWORD_MANAGEMENT"
      ],
      [
        "auth",
        "establish_base_security_policy",
        "IN p_tenant_hk bytea, IN p_policy_name character varying",
        null,
        "plpgsql",
        "\nDECLARE\n    v_policy_bk VARCHAR(50);\n    v_policy_hk BYTEA;\n    v_base_hash_diff BYTEA;\nBEGIN\n    -- Generate policy identifiers\n    v_policy_bk := auth.generate_policy_bk(p_tenant_hk, p_policy_name);\n    v_policy_hk := util.hash_binary(v_policy_bk);\n    \n    -- Calculate initial hash diff for satellite\n    v_base_hash_diff := util.hash_binary(v_policy_bk || CURRENT_TIMESTAMP::text);\n\n    -- Insert into hub if not exists\n    INSERT INTO auth.security_policy_h (\n        security_policy_hk,\n        security_policy_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        v_policy_hk,\n        v_policy_bk,\n        p_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    ) ON CONFLICT (security_policy_hk) DO NOTHING;\n\n    -- Insert HIPAA-compliant security settings into satellite\n    INSERT INTO auth.security_policy_s (\n        security_policy_hk,\n        load_date,\n        hash_diff,\n        policy_name,\n        policy_description,\n        password_min_length,\n        password_require_uppercase,\n        password_require_lowercase,\n        password_require_number,\n        password_require_special,\n        password_expiry_days,\n        account_lockout_threshold,\n        account_lockout_duration_minutes,\n        session_timeout_minutes,\n        require_mfa,\n        password_history_count,\n        session_absolute_timeout_hours,\n        mfa_timeout_minutes,\n        is_active,\n        record_source\n    ) VALUES (\n        v_policy_hk,\n        util.current_load_date(),\n        v_base_hash_diff,\n        p_policy_name,\n        'HIPAA-compliant security policy for tenant',\n        12,                   -- password_min_length: Strong password requirement\n        TRUE,                 -- password_require_uppercase: Enhanced password complexity\n        TRUE,                 -- password_require_lowercase: Enhanced password complexity\n        TRUE,                 -- password_require_number: Enhanced password complexity\n        TRUE,                 -- password_require_special: Complex password requirement\n        90,                   -- password_expiry_days: HIPAA password change requirement\n        5,                    -- account_lockout_threshold: HIPAA recommends limiting failed attempts\n        30,                   -- account_lockout_duration_minutes: 30-minute lockout period\n        15,                   -- session_timeout_minutes: HIPAA requires automatic logoff\n        TRUE,                 -- require_mfa: Enhanced security requirement\n        24,                   -- password_history_count: Prevent password reuse\n        12,                   -- session_absolute_timeout_hours: Maximum session duration\n        5,                    -- mfa_timeout_minutes: MFA code expiration\n        TRUE,                 -- is_active: Policy is active\n        util.get_record_source()\n    );\nEND;\n",
        "Creates HIPAA-compliant base security policy for a tenant with enterprise-grade security defaults",
        "SECURITY_POLICY"
      ],
      [
        "auth",
        "get_tenant_security_policy",
        "p_tenant_hk bytea",
        "TABLE(security_policy_hk bytea, policy_name character varying, password_min_length integer, session_timeout_minutes integer, require_mfa boolean, is_hipaa_compliant boolean)",
        "plpgsql",
        "\nBEGIN\n    RETURN QUERY\n    WITH policy_data AS (\n        SELECT \n            sp_h.security_policy_hk,\n            sp_s.policy_name,\n            sp_s.password_min_length,\n            sp_s.session_timeout_minutes,\n            sp_s.require_mfa,\n            sp_s.password_require_special,\n            sp_s.password_require_number,\n            sp_s.password_require_uppercase,\n            sp_s.password_expiry_days,\n            sp_s.password_history_count,\n            sp_s.account_lockout_threshold\n        FROM auth.security_policy_h sp_h\n        JOIN auth.security_policy_s sp_s ON sp_h.security_policy_hk = sp_s.security_policy_hk\n        WHERE sp_h.tenant_hk = p_tenant_hk\n        AND sp_s.is_active = TRUE\n        AND sp_s.load_end_date IS NULL\n        ORDER BY sp_s.load_date DESC\n        LIMIT 1\n    )\n    SELECT \n        pd.security_policy_hk,\n        pd.policy_name,\n        pd.password_min_length,\n        pd.session_timeout_minutes,\n        pd.require_mfa,\n        CASE \n            WHEN pd.password_min_length >= 12 \n            AND pd.password_require_special \n            AND pd.password_require_number \n            AND pd.password_require_uppercase\n            AND pd.password_expiry_days <= 90\n            AND pd.session_timeout_minutes <= 15\n            AND pd.require_mfa\n            AND pd.password_history_count >= 12\n            AND pd.account_lockout_threshold <= 5\n            THEN TRUE \n            ELSE FALSE \n        END AS is_hipaa_compliant\n    FROM policy_data pd;\nEND;\n",
        "Retrieves active security policy for a tenant with HIPAA compliance status indicator",
        "SECURITY_POLICY"
      ],
      [
        "auth",
        "maintain_security_state",
        "",
        null,
        "plpgsql",
        "\nDECLARE\n    v_audit_event_bk VARCHAR(255);\n    v_audit_event_hk BYTEA;\n    v_expired_sessions INTEGER := 0;\n    v_unlocked_accounts INTEGER := 0;\n    v_representative_tenant_hk BYTEA;\nBEGIN\n    -- Get a representative tenant for audit logging\n    SELECT tenant_hk INTO v_representative_tenant_hk\n    FROM auth.tenant_h\n    LIMIT 1;\n\n    -- Create audit event for maintenance\n    v_audit_event_bk := 'SECURITY_MAINTENANCE_' || to_char(CURRENT_TIMESTAMP, 'YYYYMMDD_HH24MISS');\n    v_audit_event_hk := util.hash_binary(v_audit_event_bk);\n\n    -- Expire old sessions based on security policy\n    WITH expired_session_updates AS (\n        INSERT INTO auth.session_state_s (\n            session_hk,\n            load_date,\n            hash_diff,\n            session_start,\n            session_end,\n            ip_address,\n            user_agent,\n            session_data,\n            session_status,\n            last_activity,\n            record_source\n        )\n        SELECT \n            sss.session_hk,\n            util.current_load_date(),\n            util.hash_binary(sh.session_bk || 'EXPIRED' || CURRENT_TIMESTAMP::text),\n            sss.session_start,\n            CURRENT_TIMESTAMP, -- session_end\n            sss.ip_address,\n            sss.user_agent,\n            sss.session_data,\n            'EXPIRED',\n            sss.last_activity,\n            util.get_record_source()\n        FROM auth.session_state_s sss\n        JOIN auth.session_h sh ON sss.session_hk = sh.session_hk\n        LEFT JOIN auth.security_policy_h sph ON sh.tenant_hk = sph.tenant_hk\n        LEFT JOIN auth.security_policy_s sp ON sph.security_policy_hk = sp.security_policy_hk \n            AND sp.is_active = TRUE AND sp.load_end_date IS NULL\n        WHERE sss.session_status = 'ACTIVE'\n        AND sss.load_end_date IS NULL\n        AND (\n            sss.last_activity < (CURRENT_TIMESTAMP - (COALESCE(sp.session_timeout_minutes, 60) || ' minutes')::interval)\n            OR sss.session_start < (CURRENT_TIMESTAMP - (COALESCE(sp.session_absolute_timeout_hours, 12) || ' hours')::interval)\n        )\n        RETURNING session_hk\n    )\n    SELECT COUNT(*) INTO v_expired_sessions FROM expired_session_updates;\n\n    -- End-date the previous session state records that were expired\n    UPDATE auth.session_state_s sss\n    SET load_end_date = util.current_load_date()\n    FROM auth.session_h sh\n    LEFT JOIN auth.security_policy_h sph ON sh.tenant_hk = sph.tenant_hk\n    LEFT JOIN auth.security_policy_s sp ON sph.security_policy_hk = sp.security_policy_hk \n        AND sp.is_active = TRUE AND sp.load_end_date IS NULL\n    WHERE sss.session_hk = sh.session_hk\n    AND sss.session_status = 'ACTIVE'\n    AND sss.load_end_date IS NULL\n    AND sss.load_date < util.current_load_date()\n    AND (\n        sss.last_activity < (CURRENT_TIMESTAMP - (COALESCE(sp.session_timeout_minutes, 60) || ' minutes')::interval)\n        OR sss.session_start < (CURRENT_TIMESTAMP - (COALESCE(sp.session_absolute_timeout_hours, 12) || ' hours')::interval)\n    );\n\n    -- Unlock accounts where lockout period has expired\n    WITH unlocked_account_updates AS (\n        INSERT INTO auth.user_auth_s (\n            user_hk,\n            load_date,\n            hash_diff,\n            username,\n            password_hash,\n            password_salt,\n            last_login_date,\n            password_last_changed,\n            failed_login_attempts,\n            account_locked,\n            account_locked_until,\n            must_change_password,\n            record_source\n        )\n        SELECT \n            user_hk,\n            util.current_load_date(),\n            util.hash_binary(username || 'AUTO_UNLOCK' || CURRENT_TIMESTAMP::text),\n            username,\n            password_hash,\n            password_salt,\n            last_login_date,\n            password_last_changed,\n            0, -- Reset failed attempts\n            FALSE, -- account_locked\n            NULL, -- account_locked_until\n            must_change_password,\n            util.get_record_source()\n        FROM auth.user_auth_s\n        WHERE account_locked = TRUE\n        AND account_locked_until < CURRENT_TIMESTAMP\n        AND load_end_date IS NULL\n        RETURNING user_hk\n    )\n    SELECT COUNT(*) INTO v_unlocked_accounts FROM unlocked_account_updates;\n\n    -- End-date the previous locked auth records\n    UPDATE auth.user_auth_s\n    SET load_end_date = util.current_load_date()\n    WHERE account_locked = TRUE\n    AND account_locked_until < CURRENT_TIMESTAMP\n    AND load_end_date IS NULL\n    AND load_date < util.current_load_date();\n\n    -- Log the maintenance activity if any changes were made and we have a tenant\n    IF (v_expired_sessions > 0 OR v_unlocked_accounts > 0) AND v_representative_tenant_hk IS NOT NULL THEN\n        INSERT INTO audit.audit_event_h (\n            audit_event_hk,\n            audit_event_bk,\n            tenant_hk,\n            load_date,\n            record_source\n        ) VALUES (\n            v_audit_event_hk,\n            v_audit_event_bk,\n            v_representative_tenant_hk,\n            util.current_load_date(),\n            util.get_record_source()\n        );\n\n        -- Log maintenance details\n        INSERT INTO audit.audit_detail_s (\n            audit_event_hk,\n            hash_diff,\n            table_name,\n            operation,\n            changed_by,\n            old_data,\n            new_data\n        ) VALUES (\n            v_audit_event_hk,\n            util.hash_binary('SECURITY_MAINTENANCE_' || CURRENT_TIMESTAMP::text),\n            'auth.session_state_s, auth.user_auth_s',\n            'MAINTENANCE',\n            SESSION_USER,\n            NULL,\n            jsonb_build_object(\n                'maintenance_time', CURRENT_TIMESTAMP,\n                'expired_sessions', v_expired_sessions,\n                'unlocked_accounts', v_unlocked_accounts\n            )\n        );\n    END IF;\nEND;\n",
        null,
        "SECURITY_POLICY"
      ],
      [
        "auth",
        "update_security_policy",
        "IN p_policy_hk bytea, IN p_updates jsonb",
        null,
        "plpgsql",
        "\nDECLARE\n    v_current_policy auth.security_policy_s%ROWTYPE;\n    v_new_hash_diff BYTEA;\nBEGIN\n    -- Get current policy settings\n    SELECT * INTO v_current_policy\n    FROM auth.security_policy_s\n    WHERE security_policy_hk = p_policy_hk\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    -- Calculate new hash diff\n    v_new_hash_diff := util.hash_binary(\n        p_policy_hk::text || \n        COALESCE(p_updates->>'password_min_length', v_current_policy.password_min_length::text) ||\n        CURRENT_TIMESTAMP::text\n    );\n\n    -- Insert new policy version with updated settings\n    INSERT INTO auth.security_policy_s (\n        security_policy_hk,\n        load_date,\n        load_end_date,\n        hash_diff,\n        policy_name,\n        policy_description,\n        password_min_length,\n        password_require_uppercase,\n        password_require_lowercase,\n        password_require_number,\n        password_require_special,\n        password_expiry_days,\n        account_lockout_threshold,\n        account_lockout_duration_minutes,\n        session_timeout_minutes,\n        require_mfa,\n        password_history_count,\n        session_absolute_timeout_hours,\n        mfa_timeout_minutes,\n        is_active,\n        record_source\n    )\n    SELECT\n        p_policy_hk,\n        util.current_load_date(),\n        NULL, -- load_end_date\n        v_new_hash_diff,\n        COALESCE(p_updates->>'policy_name', policy_name),\n        COALESCE(p_updates->>'policy_description', policy_description),\n        COALESCE((p_updates->>'password_min_length')::integer, password_min_length),\n        COALESCE((p_updates->>'password_require_uppercase')::boolean, password_require_uppercase),\n        COALESCE((p_updates->>'password_require_lowercase')::boolean, password_require_lowercase),\n        COALESCE((p_updates->>'password_require_number')::boolean, password_require_number),\n        COALESCE((p_updates->>'password_require_special')::boolean, password_require_special),\n        COALESCE((p_updates->>'password_expiry_days')::integer, password_expiry_days),\n        COALESCE((p_updates->>'account_lockout_threshold')::integer, account_lockout_threshold),\n        COALESCE((p_updates->>'account_lockout_duration_minutes')::integer, account_lockout_duration_minutes),\n        COALESCE((p_updates->>'session_timeout_minutes')::integer, session_timeout_minutes),\n        COALESCE((p_updates->>'require_mfa')::boolean, require_mfa),\n        COALESCE((p_updates->>'password_history_count')::integer, password_history_count),\n        COALESCE((p_updates->>'session_absolute_timeout_hours')::integer, session_absolute_timeout_hours),\n        COALESCE((p_updates->>'mfa_timeout_minutes')::integer, mfa_timeout_minutes),\n        COALESCE((p_updates->>'is_active')::boolean, is_active),\n        util.get_record_source()\n    FROM auth.security_policy_s\n    WHERE security_policy_hk = p_policy_hk\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    -- End-date the previous record\n    UPDATE auth.security_policy_s\n    SET load_end_date = util.current_load_date()\n    WHERE security_policy_hk = p_policy_hk\n    AND load_date = v_current_policy.load_date;\nEND;\n",
        null,
        "SECURITY_POLICY"
      ],
      [
        "auth",
        "bulk_expire_sessions",
        "p_session_hks bytea[]",
        "TABLE(sessions_processed integer, processing_time_ms integer)",
        "plpgsql",
        "\nDECLARE\n    v_start_time TIMESTAMP WITH TIME ZONE;\n    v_end_time TIMESTAMP WITH TIME ZONE;\n    v_sessions_processed INTEGER;\nBEGIN\n    v_start_time := CURRENT_TIMESTAMP;\n    \n    -- Bulk insert new expired session records\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        session_end,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    )\n    SELECT \n        sss.session_hk,\n        util.current_load_date(),\n        util.hash_binary(sh.session_bk || 'BULK_EXPIRED' || CURRENT_TIMESTAMP::text),\n        sss.session_start,\n        CURRENT_TIMESTAMP,\n        sss.ip_address,\n        sss.user_agent,\n        sss.session_data,\n        'EXPIRED',\n        sss.last_activity,\n        util.get_record_source()\n    FROM auth.session_state_s sss\n    JOIN auth.session_h sh ON sss.session_hk = sh.session_hk\n    WHERE sss.session_hk = ANY(p_session_hks)\n    AND sss.session_status = 'ACTIVE'\n    AND sss.load_end_date IS NULL;\n\n    GET DIAGNOSTICS v_sessions_processed = ROW_COUNT;\n\n    -- Bulk end-date previous records\n    UPDATE auth.session_state_s\n    SET load_end_date = util.current_load_date()\n    WHERE session_hk = ANY(p_session_hks)\n    AND session_status = 'ACTIVE'\n    AND load_end_date IS NULL\n    AND load_date < util.current_load_date();\n\n    v_end_time := CURRENT_TIMESTAMP;\n    \n    RETURN QUERY SELECT \n        v_sessions_processed,\n        EXTRACT(EPOCH FROM (v_end_time - v_start_time))::INTEGER * 1000;\nEND;\n",
        null,
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "cleanup_expired_sessions",
        "",
        "TABLE(sessions_expired integer, tokens_revoked integer, cleanup_duration_ms integer)",
        "plpgsql",
        "\nDECLARE\n    v_start_time TIMESTAMP WITH TIME ZONE;\n    v_end_time TIMESTAMP WITH TIME ZONE;\n    v_sessions_expired INTEGER := 0;\n    v_tokens_revoked INTEGER := 0;\n    v_cleanup_duration_ms INTEGER;\n    v_representative_tenant_hk BYTEA;\nBEGIN\n    v_start_time := CURRENT_TIMESTAMP;\n    \n    -- Get a representative tenant for logging\n    SELECT tenant_hk INTO v_representative_tenant_hk\n    FROM auth.tenant_h\n    LIMIT 1;\n    \n    -- Expire sessions based on security policies\n    WITH expired_sessions AS (\n        INSERT INTO auth.session_state_s (\n            session_hk,\n            load_date,\n            hash_diff,\n            session_start,\n            session_end,\n            ip_address,\n            user_agent,\n            session_data,\n            session_status,\n            last_activity,\n            record_source\n        )\n        SELECT \n            sss.session_hk,\n            util.current_load_date(),\n            util.hash_binary(sh.session_bk || 'EXPIRED_CLEANUP' || CURRENT_TIMESTAMP::text),\n            sss.session_start,\n            CURRENT_TIMESTAMP,\n            sss.ip_address,\n            sss.user_agent,\n            sss.session_data,\n            'EXPIRED',\n            sss.last_activity,\n            util.get_record_source()\n        FROM auth.session_state_s sss\n        JOIN auth.session_h sh ON sss.session_hk = sh.session_hk\n        LEFT JOIN auth.security_policy_h sph ON sh.tenant_hk = sph.tenant_hk\n        LEFT JOIN auth.security_policy_s sp ON sph.security_policy_hk = sp.security_policy_hk \n            AND sp.is_active = TRUE AND sp.load_end_date IS NULL\n        WHERE sss.session_status = 'ACTIVE'\n        AND sss.load_end_date IS NULL\n        AND (\n            sss.last_activity < (CURRENT_TIMESTAMP - (COALESCE(sp.session_timeout_minutes, 60) || ' minutes')::interval)\n            OR sss.session_start < (CURRENT_TIMESTAMP - (COALESCE(sp.session_absolute_timeout_hours, 12) || ' hours')::interval)\n        )\n        RETURNING session_hk\n    )\n    SELECT COUNT(*) INTO v_sessions_expired FROM expired_sessions;\n    \n    -- End-date the previous session records\n    UPDATE auth.session_state_s sss\n    SET load_end_date = util.current_load_date()\n    FROM auth.session_h sh\n    LEFT JOIN auth.security_policy_h sph ON sh.tenant_hk = sph.tenant_hk\n    LEFT JOIN auth.security_policy_s sp ON sph.security_policy_hk = sp.security_policy_hk \n        AND sp.is_active = TRUE AND sp.load_end_date IS NULL\n    WHERE sss.session_hk = sh.session_hk\n    AND sss.session_status = 'ACTIVE'\n    AND sss.load_end_date IS NULL\n    AND sss.load_date < util.current_load_date()\n    AND (\n        sss.last_activity < (CURRENT_TIMESTAMP - (COALESCE(sp.session_timeout_minutes, 60) || ' minutes')::interval)\n        OR sss.session_start < (CURRENT_TIMESTAMP - (COALESCE(sp.session_absolute_timeout_hours, 12) || ' hours')::interval)\n    );\n    \n    -- Revoke tokens for expired sessions if token management exists\n    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'auth' AND table_name = 'api_token_s') THEN\n        WITH revoked_tokens AS (\n            INSERT INTO auth.api_token_s (\n                token_hk,\n                load_date,\n                hash_diff,\n                token_hash,\n                token_type,\n                expires_at,\n                is_revoked,\n                revocation_reason,\n                scope,\n                last_used_at,\n                record_source\n            )\n            SELECT \n                ats.token_hk,\n                util.current_load_date(),\n                util.hash_binary(ats.token_hash::text || 'SESSION_EXPIRED' || CURRENT_TIMESTAMP::text),\n                ats.token_hash,\n                ats.token_type,\n                ats.expires_at,\n                TRUE,\n                'Session expired during cleanup',\n                ats.scope,\n                ats.last_used_at,\n                util.get_record_source()\n            FROM auth.api_token_s ats\n            JOIN auth.session_token_l stl ON ats.token_hk = stl.token_hk\n            JOIN auth.session_state_s sss ON stl.session_hk = sss.session_hk\n            WHERE sss.session_status = 'EXPIRED'\n            AND ats.is_revoked = FALSE\n            AND ats.load_end_date IS NULL\n            AND sss.load_date >= v_start_time\n            RETURNING token_hk\n        )\n        SELECT COUNT(*) INTO v_tokens_revoked FROM revoked_tokens;\n    END IF;\n    \n    v_end_time := CURRENT_TIMESTAMP;\n    v_cleanup_duration_ms := EXTRACT(EPOCH FROM (v_end_time - v_start_time)) * 1000;\n    \n    -- Log the cleanup operation\n    IF v_sessions_expired > 0 OR v_tokens_revoked > 0 THEN\n        PERFORM audit.log_security_event(\n            COALESCE(v_representative_tenant_hk, decode('00000000', 'hex')),\n            'SESSION_CLEANUP',\n            format('Automated cleanup expired %s sessions and revoked %s tokens', v_sessions_expired, v_tokens_revoked),\n            jsonb_build_object(\n                'sessions_expired', v_sessions_expired,\n                'tokens_revoked', v_tokens_revoked,\n                'cleanup_duration_ms', v_cleanup_duration_ms\n            )\n        );\n    END IF;\n    \n    RETURN QUERY SELECT v_sessions_expired, v_tokens_revoked, v_cleanup_duration_ms;\nEND;\n",
        "Automated session cleanup with comprehensive logging and token revocation for security maintenance",
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "validate_session",
        "IN p_session_token text, IN p_ip_address inet, IN p_user_agent text, OUT p_is_valid boolean, OUT p_message text, OUT p_user_context jsonb",
        null,
        "plpgsql",
        "\nDECLARE\n    v_validation_result RECORD;\nBEGIN\n    -- Initialize outputs\n    p_is_valid := FALSE;\n    p_message := 'Invalid session';\n    p_user_context := NULL;\n\n    -- Call the internal validation function\n    SELECT \n        is_valid, \n        user_hk,\n        session_hk,\n        username,\n        message\n    INTO v_validation_result\n    FROM auth.validate_token_and_session(\n        p_session_token,\n        p_ip_address,\n        p_user_agent\n    );\n    \n    -- Handle invalid session\n    IF NOT COALESCE(v_validation_result.is_valid, FALSE) THEN\n        p_is_valid := FALSE;\n        p_message := COALESCE(v_validation_result.message, 'Session validation failed');\n        RETURN;\n    END IF;\n    \n    -- Get user and tenant context\n    SELECT jsonb_build_object(\n        'user_id', u.user_bk,\n        'tenant_id', t.tenant_bk,\n        'email', uas.username,\n        'first_name', COALESCE(ups.first_name, ''),\n        'last_name', COALESCE(ups.last_name, ''),\n        'roles', COALESCE(\n            (SELECT array_agg(rds.role_name)\n             FROM auth.user_role_l url\n             JOIN auth.role_h r ON url.role_hk = r.role_hk\n             JOIN auth.role_definition_s rds ON r.role_hk = rds.role_hk\n             WHERE url.user_hk = u.user_hk\n             AND rds.load_date = (\n                 SELECT MAX(load_date)\n                 FROM auth.role_definition_s\n                 WHERE role_hk = r.role_hk\n                 AND load_end_date IS NULL\n             )), \n            ARRAY[]::TEXT[]\n        )\n    ) INTO p_user_context\n    FROM auth.user_h u\n    JOIN auth.tenant_h t ON u.tenant_hk = t.tenant_hk\n    JOIN auth.user_auth_s uas ON u.user_hk = uas.user_hk\n    LEFT JOIN auth.user_profile_s ups ON u.user_hk = ups.user_hk\n    WHERE u.user_hk = v_validation_result.user_hk\n    AND uas.load_date = (\n        SELECT MAX(load_date) \n        FROM auth.user_auth_s \n        WHERE user_hk = u.user_hk \n        AND load_end_date IS NULL\n    )\n    AND (ups.load_date IS NULL OR ups.load_date = (\n        SELECT MAX(load_date) \n        FROM auth.user_profile_s \n        WHERE user_hk = u.user_hk \n        AND load_end_date IS NULL\n    ));\n    \n    -- Update session activity\n    UPDATE auth.session_state_s\n    SET last_activity = CURRENT_TIMESTAMP,\n        load_end_date = util.current_load_date()\n    WHERE session_hk = v_validation_result.session_hk\n    AND load_end_date IS NULL;\n    \n    -- Insert new session state record\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    )\n    SELECT \n        session_hk,\n        util.current_load_date(),\n        util.hash_binary(session_bk || 'ACTIVE_UPDATED'),\n        session_start,\n        p_ip_address,\n        p_user_agent,\n        session_data,\n        'ACTIVE',\n        CURRENT_TIMESTAMP,\n        util.get_record_source()\n    FROM auth.session_state_s\n    WHERE session_hk = v_validation_result.session_hk\n    AND load_end_date = util.current_load_date();\n    \n    p_is_valid := TRUE;\n    p_message := 'Session valid';\n\nEXCEPTION WHEN OTHERS THEN\n    p_is_valid := FALSE;\n    p_message := 'Session validation failed';\n    p_user_context := NULL;\nEND;\n",
        "Validates session tokens and returns user context for API requests",
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "validate_session_enhanced",
        "p_session_hk bytea, p_ip_address inet, p_user_agent text",
        "TABLE(is_valid boolean, validation_message text, user_hk bytea, requires_mfa boolean, session_expires_at timestamp with time zone)",
        "plpgsql",
        "\nDECLARE\n    v_session_data RECORD;\n    v_security_policy RECORD;\nBEGIN\n    -- Get session and related data\n    SELECT \n        sss.session_status,\n        sss.session_start,\n        sss.last_activity,\n        sss.ip_address,\n        sss.session_data,\n        usl.user_hk,\n        sh.tenant_hk\n    INTO v_session_data\n    FROM auth.session_state_s sss\n    JOIN auth.session_h sh ON sss.session_hk = sh.session_hk\n    JOIN auth.user_session_l usl ON sh.session_hk = usl.session_hk\n    WHERE sss.session_hk = p_session_hk\n    AND sss.load_end_date IS NULL\n    ORDER BY sss.load_date DESC\n    LIMIT 1;\n\n    -- If no session found\n    IF v_session_data.session_status IS NULL THEN\n        RETURN QUERY SELECT FALSE, 'Session not found', NULL::BYTEA, FALSE, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Get security policy\n    SELECT \n        COALESCE(sp.session_timeout_minutes, 60) as session_timeout_minutes,\n        COALESCE(sp.session_absolute_timeout_hours, 12) as session_absolute_timeout_hours,\n        COALESCE(sp.require_mfa, false) as require_mfa,\n        sp.allowed_ip_ranges\n    INTO v_security_policy\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h sph ON sp.security_policy_hk = sph.security_policy_hk\n    WHERE sph.tenant_hk = v_session_data.tenant_hk\n    AND sp.is_active = TRUE\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n\n    -- Set defaults if no policy found\n    IF v_security_policy.session_timeout_minutes IS NULL THEN\n        v_security_policy.session_timeout_minutes := 60;\n        v_security_policy.session_absolute_timeout_hours := 12;\n        v_security_policy.require_mfa := false;\n    END IF;\n\n    -- Validate session status\n    IF v_session_data.session_status != 'ACTIVE' THEN\n        RETURN QUERY SELECT FALSE, 'Session is not active', v_session_data.user_hk, \n                           v_security_policy.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Check session timeout\n    IF v_session_data.last_activity < (CURRENT_TIMESTAMP - (v_security_policy.session_timeout_minutes || ' minutes')::interval) THEN\n        RETURN QUERY SELECT FALSE, 'Session has timed out due to inactivity', v_session_data.user_hk, \n                           v_security_policy.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Check absolute session timeout\n    IF v_session_data.session_start < (CURRENT_TIMESTAMP - (v_security_policy.session_absolute_timeout_hours || ' hours')::interval) THEN\n        RETURN QUERY SELECT FALSE, 'Session has exceeded maximum duration', v_session_data.user_hk, \n                           v_security_policy.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Check IP address validation if configured\n    IF v_security_policy.allowed_ip_ranges IS NOT NULL AND array_length(v_security_policy.allowed_ip_ranges, 1) > 0 THEN\n        -- Simple IP validation (can be enhanced for CIDR ranges)\n        IF NOT (p_ip_address::text = ANY(v_security_policy.allowed_ip_ranges)) THEN\n            RETURN QUERY SELECT FALSE, 'IP address not allowed', v_session_data.user_hk, \n                               v_security_policy.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n            RETURN;\n        END IF;\n    END IF;\n\n    -- Update last activity time\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        session_end,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    ) VALUES (\n        p_session_hk,\n        util.current_load_date(),\n        util.hash_binary(p_session_hk::text || 'ACTIVITY_UPDATE' || CURRENT_TIMESTAMP::text),\n        v_session_data.session_start,\n        NULL, -- session_end\n        p_ip_address,\n        p_user_agent,\n        v_session_data.session_data,\n        'ACTIVE',\n        CURRENT_TIMESTAMP, -- last_activity\n        util.get_record_source()\n    );\n\n    -- End-date the previous session state record\n    UPDATE auth.session_state_s\n    SET load_end_date = util.current_load_date()\n    WHERE session_hk = p_session_hk\n    AND load_end_date IS NULL\n    AND load_date < util.current_load_date();\n\n    -- Calculate session expiration time\n    RETURN QUERY SELECT \n        TRUE, \n        'Session is valid', \n        v_session_data.user_hk, \n        v_security_policy.require_mfa,\n        LEAST(\n            v_session_data.last_activity + (v_security_policy.session_timeout_minutes || ' minutes')::interval,\n            v_session_data.session_start + (v_security_policy.session_absolute_timeout_hours || ' hours')::interval\n        );\nEND;\n",
        null,
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "validate_session_json",
        "p_session_token text, p_ip_address text, p_user_agent text",
        "jsonb",
        "plpgsql",
        "\nDECLARE\n    v_is_valid BOOLEAN;\n    v_message TEXT;\n    v_user_context JSONB;\n    v_inet_address INET;\nBEGIN\n    -- Handle IP address conversion safely\n    BEGIN\n        v_inet_address := p_ip_address::INET;\n    EXCEPTION WHEN OTHERS THEN\n        v_inet_address := '0.0.0.0'::INET;\n    END;\n\n    -- Call the existing procedure\n    CALL auth.validate_session(\n        p_session_token,\n        v_inet_address,\n        p_user_agent,\n        v_is_valid,\n        v_message,\n        v_user_context\n    );\n    \n    -- Return consolidated JSON response\n    RETURN jsonb_build_object(\n        'valid', v_is_valid,\n        'message', v_message,\n        'userContext', v_user_context,\n        'timestamp', CURRENT_TIMESTAMP\n    );\nEXCEPTION WHEN OTHERS THEN\n    -- Handle unexpected errors gracefully\n    RETURN jsonb_build_object(\n        'valid', FALSE,\n        'message', 'An unexpected error occurred during session validation: ' || SQLERRM,\n        'userContext', NULL,\n        'timestamp', CURRENT_TIMESTAMP,\n        'errorCode', SQLSTATE\n    );\nEND;\n",
        "JSON wrapper for session validation, convenient for REST API integration",
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "validate_session_optimized",
        "p_session_hk bytea, p_ip_address inet, p_user_agent text",
        "TABLE(is_valid boolean, validation_message text, user_hk bytea, requires_mfa boolean, session_expires_at timestamp with time zone)",
        "plpgsql",
        "\nDECLARE\n    v_session_data RECORD;\n    v_policy_data RECORD;\n    v_start_time TIMESTAMP WITH TIME ZONE;\nBEGIN\n    v_start_time := CURRENT_TIMESTAMP;\n    \n    -- Get session data using optimized index\n    SELECT \n        sss.session_status,\n        sss.session_start,\n        sss.last_activity,\n        usl.user_hk,\n        sh.tenant_hk\n    INTO v_session_data\n    FROM auth.session_state_s sss\n    JOIN auth.session_h sh ON sss.session_hk = sh.session_hk\n    JOIN auth.user_session_l usl ON sh.session_hk = usl.session_hk\n    WHERE sss.session_hk = p_session_hk\n    AND sss.session_status = 'ACTIVE'\n    AND sss.load_end_date IS NULL\n    ORDER BY sss.load_date DESC\n    LIMIT 1;\n\n    -- If no active session found\n    IF v_session_data.session_status IS NULL THEN\n        RETURN QUERY SELECT FALSE, 'Session not found or inactive', NULL::BYTEA, FALSE, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Get policy data from materialized view\n    SELECT \n        mtsp.session_timeout_minutes,\n        mtsp.require_mfa\n    INTO v_policy_data\n    FROM auth.mv_tenant_security_policies mtsp\n    WHERE mtsp.tenant_hk = v_session_data.tenant_hk\n    AND mtsp.rn = 1;\n\n    -- Set defaults if no policy found\n    IF v_policy_data.session_timeout_minutes IS NULL THEN\n        v_policy_data.session_timeout_minutes := 60;\n        v_policy_data.require_mfa := false;\n    END IF;\n\n    -- Check session timeouts (using only available timeout setting)\n    IF v_session_data.last_activity < (CURRENT_TIMESTAMP - (v_policy_data.session_timeout_minutes || ' minutes')::interval) THEN\n        RETURN QUERY SELECT FALSE, 'Session timeout due to inactivity', v_session_data.user_hk, \n                           v_policy_data.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Update last activity efficiently\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        session_end,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    ) VALUES (\n        p_session_hk,\n        util.current_load_date(),\n        util.hash_binary(p_session_hk::text || 'ACTIVITY_UPDATE' || CURRENT_TIMESTAMP::text),\n        v_session_data.session_start,\n        NULL,\n        p_ip_address,\n        p_user_agent,\n        jsonb_build_object('optimized_validation', true),\n        'ACTIVE',\n        CURRENT_TIMESTAMP,\n        util.get_record_source()\n    );\n\n    -- End-date previous record\n    UPDATE auth.session_state_s\n    SET load_end_date = util.current_load_date()\n    WHERE session_hk = p_session_hk\n    AND load_end_date IS NULL\n    AND load_date < util.current_load_date();\n\n    -- Log performance metrics\n    PERFORM util.analyze_query_performance(\n        'validate_session_optimized',\n        v_session_data.tenant_hk\n    );\n\n    -- Return successful validation\n    RETURN QUERY SELECT \n        TRUE, \n        'Session is valid', \n        v_session_data.user_hk, \n        v_policy_data.require_mfa,\n        v_session_data.last_activity + (v_policy_data.session_timeout_minutes || ' minutes')::interval;\nEND;\n",
        "High-performance session validation using materialized views and optimized query patterns",
        "SESSION_MANAGEMENT"
      ],
      [
        "auth",
        "create_session_with_token",
        "IN p_user_hk bytea, IN p_ip_address inet, IN p_user_agent text, OUT p_session_hk bytea, OUT p_token_value text",
        null,
        "plpgsql",
        "\nDECLARE\n    v_tenant_hk BYTEA;\n    v_session_bk VARCHAR(255);\n    v_api_token_hk BYTEA;\n    v_security_policy auth.security_policy_s%ROWTYPE;\n    v_expires_at TIMESTAMP WITH TIME ZONE;\n    v_load_date TIMESTAMP WITH TIME ZONE;\n    v_record_source VARCHAR(100);\nBEGIN\n    -- Initialize operational variables\n    v_load_date := util.current_load_date();\n    v_record_source := util.get_record_source();\n    \n    -- Get tenant context\n    SELECT tenant_hk INTO v_tenant_hk\n    FROM auth.user_h\n    WHERE user_hk = p_user_hk;\n\n    IF v_tenant_hk IS NULL THEN\n        RAISE EXCEPTION 'User not found: %', encode(p_user_hk, 'hex');\n    END IF;\n\n    -- Get current security policy\n    SELECT sp.* INTO v_security_policy\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h hp ON sp.security_policy_hk = hp.security_policy_hk\n    WHERE hp.tenant_hk = v_tenant_hk\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n\n    -- Generate session business key and hash key\n    v_session_bk := util.generate_bk(encode(v_tenant_hk, 'hex') || '_SESSION_' || CURRENT_TIMESTAMP::text);\n    p_session_hk := util.hash_binary(v_session_bk);\n\n    -- Create session hub record\n    INSERT INTO auth.session_h (\n        session_hk,\n        session_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        p_session_hk,\n        v_session_bk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\n    -- Create session state satellite\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    ) VALUES (\n        p_session_hk,\n        v_load_date,\n        util.hash_binary(v_session_bk || 'ACTIVE' || p_ip_address::text),\n        CURRENT_TIMESTAMP,\n        p_ip_address,\n        p_user_agent,\n        jsonb_build_object(\n            'created_timestamp', CURRENT_TIMESTAMP,\n            'security_policy_applied', COALESCE(v_security_policy.policy_name, 'default')\n        ),\n        'ACTIVE',\n        CURRENT_TIMESTAMP,\n        v_record_source\n    );\n\n    -- Create user-session link\n    INSERT INTO auth.user_session_l (\n        link_user_session_hk,\n        user_hk,\n        session_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(p_user_hk::text || p_session_hk::text),\n        p_user_hk,\n        p_session_hk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\n    -- Generate associated API token\n    SELECT token_value, expires_at INTO p_token_value, v_expires_at\n    FROM auth.generate_api_token(\n        p_user_hk,\n        'SESSION',\n        ARRAY['api:access', 'session:maintain'],\n        COALESCE(v_security_policy.session_timeout_minutes, 60) * INTERVAL '1 minute'\n    );\n\n    -- Get token hash key for relationship creation\n    SELECT api_token_hk INTO v_api_token_hk\n    FROM auth.api_token_s\n    WHERE token_hash = util.hash_binary(p_token_value)\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    -- Create session-token relationship\n    INSERT INTO auth.session_token_l (\n        session_token_hk,\n        session_hk,\n        api_token_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(p_session_hk::text || v_api_token_hk::text),\n        p_session_hk,\n        v_api_token_hk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\nEND;\n",
        "Creates integrated session and API token pairs with proper relationship management and security policy enforcement. Provides seamless authentication experience while maintaining comprehensive audit documentation.",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "generate_api_token",
        "p_user_hk bytea, p_token_type character varying, p_scope text[], p_expires_in interval DEFAULT '1 day'::interval",
        "TABLE(token_value text, expires_at timestamp with time zone)",
        "plpgsql",
        "\nDECLARE\n    v_api_token_bk VARCHAR(255);\n    v_api_token_hk BYTEA;\n    v_tenant_hk BYTEA;\n    v_token_value TEXT;\n    v_expires_at TIMESTAMP WITH TIME ZONE;\n    v_token_hash BYTEA;\n    v_load_date TIMESTAMP WITH TIME ZONE;\n    v_record_source VARCHAR(100);\nBEGIN\n    -- Initialize operational variables\n    v_load_date := util.current_load_date();\n    v_record_source := util.get_record_source();\n    \n    -- Get tenant context from user\n    SELECT tenant_hk INTO v_tenant_hk\n    FROM auth.user_h\n    WHERE user_hk = p_user_hk;\n\n    IF v_tenant_hk IS NULL THEN\n        RAISE EXCEPTION 'User not found: %', encode(p_user_hk, 'hex');\n    END IF;\n\n    -- Generate cryptographically secure token\n    v_token_value := encode(gen_random_bytes(32), 'hex');\n    v_token_hash := util.hash_binary(v_token_value);\n    v_expires_at := CURRENT_TIMESTAMP + p_expires_in;\n\n    -- Create business key and hash key for token\n    v_api_token_bk := util.generate_bk(encode(v_tenant_hk, 'hex') || '_TOKEN_' || v_token_value);\n    v_api_token_hk := util.hash_binary(v_api_token_bk);\n\n    -- Create API token hub record\n    INSERT INTO auth.api_token_h (\n        api_token_hk,\n        api_token_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        v_api_token_bk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\n    -- Create API token satellite\n    INSERT INTO auth.api_token_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        scope,\n        created_by,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        v_load_date,\n        util.hash_binary(v_token_value || p_token_type || v_expires_at::text),\n        v_token_hash,\n        p_token_type,\n        v_expires_at,\n        FALSE,\n        p_scope,\n        SESSION_USER,\n        v_record_source\n    );\n\n    -- Create user-token link\n    INSERT INTO auth.user_token_l (\n        user_token_hk,\n        user_hk,\n        api_token_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(p_user_hk::text || v_api_token_hk::text),\n        p_user_hk,\n        v_api_token_hk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\n    -- Create initial activity record\n    INSERT INTO auth.token_activity_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        last_activity_timestamp,\n        activity_type,\n        activity_metadata,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        v_load_date,\n        util.hash_binary('TOKEN_CREATION' || CURRENT_TIMESTAMP::text),\n        CURRENT_TIMESTAMP,\n        'CREATION',\n        jsonb_build_object(\n            'token_type', p_token_type,\n            'scope', p_scope,\n            'expires_at', v_expires_at,\n            'created_by', SESSION_USER\n        ),\n        v_record_source\n    );\n\n    -- Return token information\n    RETURN QUERY SELECT v_token_value, v_expires_at;\nEND;\n",
        "Generates secure API tokens with comprehensive lifecycle management, audit trails, and security policy integration. Supports multiple token types and configurable expiration periods for enterprise authentication workflows.",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "generate_session_token",
        "",
        "text",
        "plpgsql",
        "\r\nBEGIN\r\n    -- Generate a 64-character hex token using timestamp + random\r\n    RETURN encode(\r\n        sha256(\r\n            (EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::text || encode(gen_random_bytes(32), 'hex'))::bytea\r\n        ), \r\n        'hex'\r\n    );\r\nEND;\r\n",
        null,
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "generate_token_for_session",
        "IN p_session_hk bytea, INOUT p_token_value text DEFAULT NULL::text",
        null,
        "plpgsql",
        "\nDECLARE\n    v_user_hk BYTEA;\n    v_tenant_hk BYTEA;\n    v_token_hk BYTEA;\n    v_link_hk BYTEA;\n    v_security_policy auth.security_policy_s%ROWTYPE;\n    v_token_hash BYTEA;\n    v_expires_at TIMESTAMP WITH TIME ZONE;\n    v_timeout_minutes NUMERIC;\n    c_MAX_HIPAA_TIMEOUT CONSTANT NUMERIC := 20;  -- Maximum 20 minutes\n    c_MIN_HIPAA_TIMEOUT CONSTANT NUMERIC := 10;  -- Minimum 10 minutes\nBEGIN\n    -- Get user_hk from session with corrected table name\n    SELECT lus.user_hk INTO v_user_hk\n    FROM auth.user_session_l lus\n    WHERE lus.session_hk = p_session_hk;\n    \n    IF v_user_hk IS NULL THEN\n        RAISE EXCEPTION 'No user found for session';\n    END IF;\n    \n    -- Get tenant_hk from user with corrected table name\n    SELECT hu.tenant_hk INTO v_tenant_hk\n    FROM auth.user_h hu\n    WHERE hu.user_hk = v_user_hk;\n    \n    IF v_tenant_hk IS NULL THEN\n        RAISE EXCEPTION 'No tenant found for user';\n    END IF;\n    \n    -- Get security policy for tenant with corrected table names\n    SELECT sp.* INTO v_security_policy\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h hp ON sp.security_policy_hk = hp.security_policy_hk\n    WHERE hp.tenant_hk = v_tenant_hk\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n    \n    -- HIPAA-Compliant Timeout Calculation\n    v_timeout_minutes := COALESCE(\n        v_security_policy.session_timeout_minutes, \n        c_MAX_HIPAA_TIMEOUT\n    );\n    \n    -- Enforce minimum and maximum timeout\n    v_timeout_minutes := LEAST(\n        GREATEST(v_timeout_minutes, c_MIN_HIPAA_TIMEOUT), \n        c_MAX_HIPAA_TIMEOUT\n    );\n    \n    -- Calculate expires_at\n    v_expires_at := CURRENT_TIMESTAMP + (v_timeout_minutes * INTERVAL '1 minute');\n    \n    -- Generate token and its hash\n    v_token_hk := util.hash_binary(gen_random_uuid()::text);\n    v_token_hash := util.hash_binary(v_token_hk::text);\n    \n    -- First, insert into api_token_h with corrected table name\n    INSERT INTO auth.api_token_h (\n        token_hk,\n        token_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        v_token_hk,\n        encode(v_token_hk, 'hex'),\n        v_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    ) ON CONFLICT DO NOTHING;\n    \n    -- Then, insert into api_token_s with corrected table name\n    INSERT INTO auth.api_token_s (\n        token_hk,\n        load_date,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        scope,\n        record_source\n    ) VALUES (\n        v_token_hk,\n        util.current_load_date(),\n        util.hash_binary(v_token_hk::text),\n        v_token_hash,\n        'SESSION',\n        v_expires_at,\n        false,\n        ARRAY['api:access'],\n        util.get_record_source()\n    );\n    \n    -- Set output token value (this will be the token_hk)\n    p_token_value := encode(v_token_hk, 'hex');\n    \n    -- Create session-token link with corrected table name\n    v_link_hk := util.hash_binary(p_session_hk::text || v_token_hk::text);\n    \n    INSERT INTO auth.session_token_l (\n        link_session_token_hk,\n        session_hk,\n        token_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        v_link_hk,\n        p_session_hk,\n        v_token_hk,\n        v_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    ) ON CONFLICT DO NOTHING;\n\n    -- Link token to user with corrected table name\n    INSERT INTO auth.user_token_l (\n        link_user_token_hk,\n        user_hk,\n        token_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(v_user_hk::text || v_token_hk::text),\n        v_user_hk,\n        v_token_hk,\n        v_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    ) ON CONFLICT DO NOTHING;\n    \nEND;\n",
        null,
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "revoke_token",
        "p_token_hash bytea, p_reason text DEFAULT 'Administrative revocation'::text",
        "boolean",
        "plpgsql",
        "\nDECLARE\n    v_api_token_hk BYTEA;\n    v_current_token auth.api_token_s%ROWTYPE;\nBEGIN\n    -- Get current token details\n    SELECT * INTO v_current_token\n    FROM auth.api_token_s\n    WHERE token_hash = p_token_hash\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    IF NOT FOUND THEN\n        RETURN FALSE;\n    END IF;\n\n    v_api_token_hk := v_current_token.api_token_hk;\n\n    -- End current token record\n    UPDATE auth.api_token_s\n    SET load_end_date = util.current_load_date()\n    WHERE api_token_hk = v_api_token_hk\n    AND load_end_date IS NULL;\n\n    -- Create revoked token record\n    INSERT INTO auth.api_token_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        revocation_reason,\n        scope,\n        last_used_at,\n        created_by,\n        revoked_by,\n        revoked_at,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        util.current_load_date(),\n        util.hash_binary(v_current_token.token_hash::text || 'REVOKED' || p_reason),\n        v_current_token.token_hash,\n        v_current_token.token_type,\n        v_current_token.expires_at,\n        TRUE,\n        p_reason,\n        v_current_token.scope,\n        v_current_token.last_used_at,\n        v_current_token.created_by,\n        SESSION_USER,\n        CURRENT_TIMESTAMP,\n        util.get_record_source()\n    );\n\n    -- Record revocation activity\n    INSERT INTO auth.token_activity_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        last_activity_timestamp,\n        activity_type,\n        activity_metadata,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        util.current_load_date(),\n        util.hash_binary('TOKEN_REVOCATION' || CURRENT_TIMESTAMP::text),\n        CURRENT_TIMESTAMP,\n        'REVOCATION',\n        jsonb_build_object(\n            'revocation_reason', p_reason,\n            'revoked_by', SESSION_USER,\n            'revoked_at', CURRENT_TIMESTAMP\n        ),\n        util.get_record_source()\n    );\n\n    RETURN TRUE;\nEND;\n",
        "Secure token revocation with comprehensive audit trails and proper cleanup of associated relationships. Supports administrative and automated revocation scenarios with detailed reason tracking.",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "revoke_token_enhanced",
        "p_token_value text, p_reason text DEFAULT 'Manual revocation'::text, p_revoked_by_user_hk bytea DEFAULT NULL::bytea",
        "boolean",
        "plpgsql",
        "\nDECLARE\n    v_token_hash BYTEA;\n    v_token_hk BYTEA;\nBEGIN\n    v_token_hash := util.hash_binary(p_token_value);\n    \n    SELECT ath.token_hk INTO v_token_hk\n    FROM auth.api_token_h ath\n    JOIN auth.api_token_s ats ON ath.token_hk = ats.token_hk\n    WHERE ats.token_hash = v_token_hash\n    AND ats.load_end_date IS NULL;\n\n    IF v_token_hk IS NULL THEN\n        RETURN false;\n    END IF;\n\n    UPDATE auth.api_token_s\n    SET load_end_date = util.current_load_date()\n    WHERE token_hk = v_token_hk\n    AND load_end_date IS NULL;\n\n    INSERT INTO auth.api_token_s (\n        token_hk,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        revocation_reason,\n        scope,\n        last_used_at\n    )\n    SELECT \n        token_hk,\n        util.hash_binary(token_hash::text || 'REVOKED' || p_reason),\n        token_hash,\n        token_type,\n        expires_at,\n        true,\n        p_reason,\n        scope,\n        last_used_at\n    FROM auth.api_token_s\n    WHERE token_hk = v_token_hk\n    AND load_end_date = util.current_load_date();\n\n    RETURN true;\nEND;\n",
        "Token revocation with comprehensive audit trail and reason tracking",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "update_token_usage",
        "p_token_hash bytea",
        "boolean",
        "plpgsql",
        "\nDECLARE\n    v_api_token_hk BYTEA;\n    v_current_token auth.api_token_s%ROWTYPE;\nBEGIN\n    -- Get current token details\n    SELECT * INTO v_current_token\n    FROM auth.api_token_s\n    WHERE token_hash = p_token_hash\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    IF NOT FOUND THEN\n        RETURN FALSE;\n    END IF;\n\n    v_api_token_hk := v_current_token.api_token_hk;\n\n    -- End current token record\n    UPDATE auth.api_token_s\n    SET load_end_date = util.current_load_date()\n    WHERE api_token_hk = v_api_token_hk\n    AND load_end_date IS NULL;\n\n    -- Create updated token record\n    INSERT INTO auth.api_token_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        revocation_reason,\n        scope,\n        last_used_at,\n        created_by,\n        revoked_by,\n        revoked_at,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        util.current_load_date(),\n        util.hash_binary(v_current_token.token_hash::text || CURRENT_TIMESTAMP::text),\n        v_current_token.token_hash,\n        v_current_token.token_type,\n        v_current_token.expires_at,\n        v_current_token.is_revoked,\n        v_current_token.revocation_reason,\n        v_current_token.scope,\n        CURRENT_TIMESTAMP,\n        v_current_token.created_by,\n        v_current_token.revoked_by,\n        v_current_token.revoked_at,\n        util.get_record_source()\n    );\n\n    RETURN TRUE;\nEND;\n",
        null,
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "validate_token_and_session",
        "p_token_value text, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_endpoint character varying DEFAULT NULL::character varying",
        "TABLE(is_valid boolean, user_hk bytea, session_hk bytea, message text)",
        "plpgsql",
        "\nDECLARE\n    v_token_hash BYTEA;\n    v_api_token_hk BYTEA;\n    v_activity_metadata JSONB;\nBEGIN\n    -- Calculate token hash for lookup\n    v_token_hash := util.hash_binary(p_token_value);\n\n    -- Comprehensive token and session validation\n    RETURN QUERY\n    WITH token_validation AS (\n        SELECT \n            ats.api_token_hk,\n            ats.token_hash,\n            ats.expires_at,\n            ats.is_revoked,\n            stl.session_hk,\n            utl.user_hk,\n            sss.session_start,\n            sss.session_status,\n            COALESCE(sps.session_timeout_minutes, 60) AS session_timeout_minutes,\n            ath.tenant_hk\n        FROM auth.api_token_s ats\n        JOIN auth.api_token_h ath ON ats.api_token_hk = ath.api_token_hk\n        LEFT JOIN auth.session_token_l stl ON ats.api_token_hk = stl.api_token_hk\n        LEFT JOIN auth.user_token_l utl ON ats.api_token_hk = utl.api_token_hk\n        LEFT JOIN auth.session_state_s sss ON stl.session_hk = sss.session_hk AND sss.load_end_date IS NULL\n        LEFT JOIN auth.security_policy_h sph ON ath.tenant_hk = sph.tenant_hk\n        LEFT JOIN auth.security_policy_s sps ON sph.security_policy_hk = sps.security_policy_hk AND sps.load_end_date IS NULL\n        WHERE ats.token_hash = v_token_hash\n        AND ats.load_end_date IS NULL\n        ORDER BY ats.load_date DESC, sss.load_date DESC, sps.load_date DESC\n        LIMIT 1\n    )\n    SELECT \n        CASE \n            WHEN tv.api_token_hk IS NULL THEN FALSE\n            WHEN tv.is_revoked THEN FALSE\n            WHEN tv.expires_at < CURRENT_TIMESTAMP THEN FALSE\n            WHEN tv.session_hk IS NOT NULL AND tv.session_status != 'ACTIVE' THEN FALSE\n            WHEN tv.session_hk IS NOT NULL AND tv.session_start + (tv.session_timeout_minutes || ' minutes')::INTERVAL < CURRENT_TIMESTAMP THEN FALSE\n            ELSE TRUE\n        END,\n        tv.user_hk,\n        tv.session_hk,\n        CASE \n            WHEN tv.api_token_hk IS NULL THEN 'Token not found'\n            WHEN tv.is_revoked THEN 'Token has been revoked'\n            WHEN tv.expires_at < CURRENT_TIMESTAMP THEN 'Token has expired'\n            WHEN tv.session_hk IS NOT NULL AND tv.session_status != 'ACTIVE' THEN 'Associated session is not active'\n            WHEN tv.session_hk IS NOT NULL AND tv.session_start + (tv.session_timeout_minutes || ' minutes')::INTERVAL < CURRENT_TIMESTAMP THEN 'Session has timed out'\n            ELSE 'Token and session are valid'\n        END\n    FROM token_validation tv;\n\n    -- Record token activity for valid tokens\n    SELECT api_token_hk INTO v_api_token_hk\n    FROM auth.api_token_s\n    WHERE token_hash = v_token_hash\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    IF v_api_token_hk IS NOT NULL THEN\n        -- Prepare activity metadata\n        v_activity_metadata := jsonb_build_object(\n            'endpoint', COALESCE(p_endpoint, 'unknown'),\n            'ip_address', COALESCE(p_ip_address::text, 'unknown'),\n            'user_agent', COALESCE(p_user_agent, 'unknown'),\n            'validation_timestamp', CURRENT_TIMESTAMP\n        );\n\n        -- End previous activity record\n        UPDATE auth.token_activity_s\n        SET load_end_date = util.current_load_date()\n        WHERE api_token_hk = v_api_token_hk\n        AND load_end_date IS NULL;\n\n        -- Create new activity record\n        INSERT INTO auth.token_activity_s (\n            api_token_hk,\n            load_date,\n            hash_diff,\n            last_activity_timestamp,\n            activity_type,\n            endpoint_accessed,\n            ip_address,\n            user_agent,\n            activity_metadata,\n            record_source\n        ) VALUES (\n            v_api_token_hk,\n            util.current_load_date(),\n            util.hash_binary(CURRENT_TIMESTAMP::text || COALESCE(p_endpoint, 'validation')),\n            CURRENT_TIMESTAMP,\n            'VALIDATION',\n            p_endpoint,\n            p_ip_address,\n            p_user_agent,\n            v_activity_metadata,\n            util.get_record_source()\n        );\n    END IF;\nEND;\n",
        "Comprehensive token and session validation with activity tracking and security monitoring. Validates token authenticity, expiration, revocation status, and associated session state for complete security verification.",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "validate_token_comprehensive",
        "p_token_value text, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_endpoint character varying DEFAULT NULL::character varying",
        "TABLE(is_valid boolean, user_hk bytea, session_hk bytea, tenant_hk bytea, username character varying, permissions text[], expires_at timestamp with time zone, message text, compliance_alert boolean)",
        "plpgsql",
        "\nDECLARE\n    v_token_hash BYTEA;\n    v_token_hk BYTEA;\n    v_user_agent_hash BYTEA;\n    v_is_compliance_event BOOLEAN := false;\nBEGIN\n    v_token_hash := util.hash_binary(p_token_value);\n    \n    v_user_agent_hash := CASE \n        WHEN p_user_agent IS NOT NULL \n        THEN util.hash_binary(p_user_agent)\n        ELSE NULL \n    END;\n\n    RETURN QUERY\n    WITH token_validation AS (\n        SELECT \n            ats.token_hk,\n            ats.token_hash,\n            ats.is_revoked,\n            ats.expires_at,\n            ats.scope,\n            uth.tenant_hk,\n            uth.user_hk,\n            utl.user_hk as linked_user_hk,\n            stl.session_hk,\n            ups.email as username,\n            sss.session_status,\n            sss.last_activity,\n            CASE \n                WHEN p_ip_address IS NOT NULL AND \n                     EXISTS (\n                         SELECT 1 FROM auth.ip_tracking_s its \n                         WHERE its.ip_address = p_ip_address \n                         AND its.suspicious_activity_flag = true\n                         AND its.load_end_date IS NULL\n                     ) THEN true\n                ELSE false\n            END as compliance_event\n        FROM auth.api_token_s ats\n        JOIN auth.api_token_h ath ON ats.token_hk = ath.token_hk\n        JOIN auth.user_token_l utl ON ath.token_hk = utl.token_hk\n        JOIN auth.user_h uth ON utl.user_hk = uth.user_hk\n        JOIN auth.user_profile_s ups ON uth.user_hk = ups.user_hk AND ups.load_end_date IS NULL\n        LEFT JOIN auth.session_token_l stl ON ath.token_hk = stl.token_hk\n        LEFT JOIN auth.session_state_s sss ON stl.session_hk = sss.session_hk AND sss.load_end_date IS NULL\n        WHERE ats.token_hash = v_token_hash\n        AND ats.load_end_date IS NULL\n        ORDER BY ats.load_date DESC\n        LIMIT 1\n    )\n    SELECT \n        CASE \n            WHEN tv.token_hk IS NULL THEN FALSE\n            WHEN tv.is_revoked THEN FALSE\n            WHEN tv.expires_at < CURRENT_TIMESTAMP THEN FALSE\n            WHEN tv.session_hk IS NOT NULL AND tv.session_status != 'ACTIVE' THEN FALSE\n            WHEN tv.session_hk IS NOT NULL AND tv.last_activity < CURRENT_TIMESTAMP - INTERVAL '20 minutes' THEN FALSE\n            ELSE TRUE\n        END as is_valid,\n        tv.linked_user_hk as user_hk,\n        tv.session_hk,\n        tv.tenant_hk,\n        tv.username,\n        tv.scope as permissions,\n        tv.expires_at,\n        CASE \n            WHEN tv.token_hk IS NULL THEN 'Token not found'\n            WHEN tv.is_revoked THEN 'Token has been revoked'\n            WHEN tv.expires_at < CURRENT_TIMESTAMP THEN 'Token has expired'\n            WHEN tv.session_hk IS NOT NULL AND tv.session_status != 'ACTIVE' THEN 'Associated session is not active'\n            WHEN tv.session_hk IS NOT NULL AND tv.last_activity < CURRENT_TIMESTAMP - INTERVAL '20 minutes' THEN 'Session has timed out'\n            ELSE 'Token is valid and active'\n        END as message,\n        tv.compliance_event as compliance_alert\n    FROM token_validation tv;\n\n    SELECT ath.token_hk INTO v_token_hk\n    FROM auth.api_token_h ath\n    JOIN auth.api_token_s ats ON ath.token_hk = ats.token_hk\n    WHERE ats.token_hash = v_token_hash\n    AND ats.load_end_date IS NULL;\n\n    IF v_token_hk IS NOT NULL THEN\n        INSERT INTO auth.token_activity_s (\n            token_hk,\n            hash_diff,\n            activity_timestamp,\n            activity_type,\n            endpoint_accessed,\n            ip_address,\n            user_agent_hash,\n            compliance_event\n        ) VALUES (\n            v_token_hk,\n            util.hash_binary('VALIDATION_' || CURRENT_TIMESTAMP::text),\n            CURRENT_TIMESTAMP,\n            'TOKEN_VALIDATION',\n            COALESCE(p_endpoint, 'unknown'),\n            p_ip_address,\n            v_user_agent_hash,\n            v_is_compliance_event\n        );\n    END IF;\nEND;\n",
        "Full token validation with activity tracking and compliance alerting",
        "TOKEN_MANAGEMENT"
      ],
      [
        "auth",
        "register_tenant",
        "IN p_tenant_name character varying, IN p_admin_email character varying, IN p_admin_password text, IN p_admin_first_name character varying, IN p_admin_last_name character varying, OUT p_tenant_hk bytea, OUT p_admin_user_hk bytea",
        null,
        "plpgsql",
        "\nDECLARE\n    v_tenant_bk VARCHAR(255);\n    v_user_bk VARCHAR(255);\n    v_salt TEXT;\n    v_password_hash TEXT;\nBEGIN\n    -- Generate tenant identifiers\n    v_tenant_bk := util.generate_bk(p_tenant_name || '_' || CURRENT_TIMESTAMP::text);\n    p_tenant_hk := util.hash_binary(v_tenant_bk);\n\n    -- Create tenant hub\n    INSERT INTO auth.tenant_h (\n        tenant_hk,\n        tenant_bk,\n        load_date,\n        record_source\n    ) VALUES (\n        p_tenant_hk,\n        v_tenant_bk,\n        util.current_load_date(),\n        util.get_record_source()\n    );\n\n    -- Create tenant profile\n    INSERT INTO auth.tenant_profile_s (\n        tenant_hk,\n        load_date,\n        hash_diff,\n        tenant_name,\n        tenant_description,\n        is_active,\n        contact_email,\n        created_date,\n        record_source\n    ) VALUES (\n        p_tenant_hk,\n        util.current_load_date(),\n        util.hash_binary(p_tenant_name || 'ACTIVE'),\n        p_tenant_name,\n        'Multi-entity business optimization tenant',\n        TRUE,\n        p_admin_email,\n        CURRENT_TIMESTAMP,\n        util.get_record_source()\n    );\n\n    -- Create admin user\n    v_user_bk := util.generate_bk(p_admin_email || '_ADMIN');\n    p_admin_user_hk := util.hash_binary(v_user_bk);\n    v_salt := gen_salt('bf');\n    v_password_hash := crypt(p_admin_password, v_salt);\n\n    -- User hub\n    INSERT INTO auth.user_h (\n        user_hk,\n        user_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        p_admin_user_hk,\n        v_user_bk,\n        p_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    );\n\n    -- User auth\n    INSERT INTO auth.user_auth_s (\n        user_hk,\n        load_date,\n        hash_diff,\n        username,\n        password_hash,\n        password_salt,\n        password_last_changed,\n        failed_login_attempts,\n        account_locked,\n        record_source\n    ) VALUES (\n        p_admin_user_hk,\n        util.current_load_date(),\n        util.hash_binary(p_admin_email || 'ADMIN'),\n        p_admin_email,\n        v_password_hash::BYTEA,\n        v_salt::BYTEA,\n        CURRENT_TIMESTAMP,\n        0,\n        FALSE,\n        util.get_record_source()\n    );\n\n    -- User profile\n    INSERT INTO auth.user_profile_s (\n        user_hk,\n        load_date,\n        hash_diff,\n        first_name,\n        last_name,\n        email,\n        is_active,\n        created_date,\n        record_source\n    ) VALUES (\n        p_admin_user_hk,\n        util.current_load_date(),\n        util.hash_binary(p_admin_first_name || p_admin_last_name),\n        p_admin_first_name,\n        p_admin_last_name,\n        p_admin_email,\n        TRUE,\n        CURRENT_TIMESTAMP,\n        util.get_record_source()\n    );\n\nEND;\n",
        null,
        "USER_REGISTRATION"
      ],
      [
        "auth",
        "register_user",
        "IN p_tenant_hk bytea, IN p_email character varying, IN p_password text, IN p_first_name character varying, IN p_last_name character varying, IN p_role_bk character varying, OUT p_user_hk bytea",
        null,
        "plpgsql",
        "\nDECLARE\n    v_user_bk VARCHAR(255);\n    v_salt TEXT;\n    v_password_hash TEXT;\n    v_role_hk BYTEA;\n    v_load_date TIMESTAMP WITH TIME ZONE;\n    v_record_source VARCHAR(100);\nBEGIN\n    -- Initialize common values\n    v_load_date := util.current_load_date();\n    v_record_source := util.get_record_source();\n\n    -- Generate user credentials\n    v_user_bk := util.generate_bk(p_email || '_USER_' || CURRENT_TIMESTAMP::text);\n    p_user_hk := util.hash_binary(v_user_bk);\n    v_salt := gen_salt('bf');\n    v_password_hash := crypt(p_password, v_salt);\n\n    -- Validate role exists\n    SELECT role_hk INTO v_role_hk\n    FROM auth.role_h\n    WHERE role_bk = p_role_bk\n    AND tenant_hk = p_tenant_hk;\n\n    IF v_role_hk IS NULL THEN\n        RAISE EXCEPTION 'Role % not found for tenant %', p_role_bk, encode(p_tenant_hk, 'hex');\n    END IF;\n\n    -- Create user hub\n    INSERT INTO auth.user_h (\n        user_hk,\n        user_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        p_user_hk,\n        v_user_bk,\n        p_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\n    -- Create authentication credentials\n    INSERT INTO auth.user_auth_s (\n        user_hk,\n        load_date,\n        hash_diff,\n        username,\n        password_hash,\n        password_salt,\n        last_login_date,\n        password_last_changed,\n        failed_login_attempts,\n        account_locked,\n        must_change_password,\n        record_source\n    ) VALUES (\n        p_user_hk,\n        v_load_date,\n        util.hash_binary(p_email || 'USER_AUTH' || CURRENT_TIMESTAMP::text),\n        p_email,\n        v_password_hash::BYTEA,\n        v_salt::BYTEA,\n        NULL,\n        CURRENT_TIMESTAMP,\n        0,\n        FALSE,\n        FALSE,\n        v_record_source\n    );\n\n    -- Create user profile\n    INSERT INTO auth.user_profile_s (\n        user_hk,\n        load_date,\n        hash_diff,\n        first_name,\n        last_name,\n        email,\n        is_active,\n        created_date,\n        record_source\n    ) VALUES (\n        p_user_hk,\n        v_load_date,\n        util.hash_binary(p_first_name || p_last_name || p_email || 'USER_PROFILE'),\n        p_first_name,\n        p_last_name,\n        p_email,\n        TRUE,\n        CURRENT_TIMESTAMP,\n        v_record_source\n    );\n\n    -- Create role assignment\n    INSERT INTO auth.user_role_l (\n        link_user_role_hk,\n        user_hk,\n        role_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(p_user_hk::text || v_role_hk::text),\n        p_user_hk,\n        v_role_hk,\n        p_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\nEXCEPTION WHEN OTHERS THEN\n    RAISE EXCEPTION 'User registration failed: % %', SQLSTATE, SQLERRM;\nEND;\n",
        null,
        "USER_REGISTRATION"
      ],
      [
        "auth",
        "validate_ai_access",
        "p_user_bk character varying, p_tenant_bk character varying, p_requested_feature character varying",
        "TABLE(p_has_access boolean, p_permissions text[], p_data_filters jsonb)",
        "plpgsql",
        "\nDECLARE\n    v_user_roles TEXT[];\n    v_has_access BOOLEAN := false;\n    v_permissions TEXT[] := '{}';\n    v_data_filters JSONB := '{}';\nBEGIN\n    -- Get user roles (simplified - would need actual role checking)\n    v_user_roles := ARRAY['ai_access', 'horse_owner', 'barn_staff'];\n    \n    -- Check if user has AI access permission\n    IF 'ai_access' = ANY(v_user_roles) THEN\n        v_has_access := true;\n        v_permissions := ARRAY['ai_chat', 'horse_info', 'training_advice'];\n        v_data_filters := '{\"scope\": \"own_horses\", \"sensitive_data\": false}';\n    END IF;\n    \n    -- Staff gets broader access\n    IF 'barn_staff' = ANY(v_user_roles) THEN\n        v_permissions := v_permissions || ARRAY['health_info', 'all_horses'];\n        v_data_filters := '{\"scope\": \"all_horses\", \"sensitive_data\": true}';\n    END IF;\n    \n    RETURN QUERY SELECT v_has_access, v_permissions, v_data_filters;\nEND;\n",
        null,
        "VALIDATION"
      ],
      [
        "auth",
        "validate_hipaa_policy",
        "p_policy_hk bytea",
        "TABLE(is_compliant boolean, validation_messages text[])",
        "plpgsql",
        "\nDECLARE\n    v_messages TEXT[] := ARRAY[]::TEXT[];\n    v_policy auth.security_policy_s%ROWTYPE;\nBEGIN\n    -- Get current policy settings\n    SELECT * INTO v_policy\n    FROM auth.security_policy_s\n    WHERE security_policy_hk = p_policy_hk\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    -- Validate each HIPAA requirement\n    IF v_policy.password_min_length < 12 THEN\n        v_messages := array_append(v_messages, 'Password length must be at least 12 characters for HIPAA compliance');\n    END IF;\n\n    IF NOT v_policy.password_require_special OR \n       NOT v_policy.password_require_number OR \n       NOT v_policy.password_require_uppercase THEN\n        v_messages := array_append(v_messages, 'Password must require special characters, numbers, and uppercase letters');\n    END IF;\n\n    IF v_policy.password_expiry_days > 90 THEN\n        v_messages := array_append(v_messages, 'Passwords must expire within 90 days for HIPAA compliance');\n    END IF;\n\n    IF v_policy.session_timeout_minutes > 15 THEN\n        v_messages := array_append(v_messages, 'Session timeout must not exceed 15 minutes for HIPAA compliance');\n    END IF;\n\n    IF NOT v_policy.require_mfa THEN\n        v_messages := array_append(v_messages, 'Multi-factor authentication must be enabled for HIPAA compliance');\n    END IF;\n\n    IF v_policy.password_history_count < 12 THEN\n        v_messages := array_append(v_messages, 'Password history must remember at least 12 previous passwords');\n    END IF;\n\n    IF v_policy.account_lockout_threshold > 5 THEN\n        v_messages := array_append(v_messages, 'Account lockout threshold should not exceed 5 failed attempts');\n    END IF;\n\n    RETURN QUERY SELECT \n        CASE WHEN array_length(v_messages, 1) IS NULL THEN TRUE ELSE FALSE END,\n        v_messages;\nEND;\n",
        "Validates security policy against HIPAA compliance requirements and returns detailed validation results",
        "VALIDATION"
      ],
      [
        "auth",
        "validate_password_policy",
        "p_tenant_hk bytea, p_password text",
        "TABLE(is_valid boolean, validation_score integer, policy_violations text[], recommendations text[])",
        "plpgsql",
        "\nDECLARE\n    v_policy auth.security_policy_s%ROWTYPE;\n    v_violations TEXT[] := ARRAY[]::TEXT[];\n    v_recommendations TEXT[] := ARRAY[]::TEXT[];\n    v_score INTEGER := 100;\nBEGIN\n    -- Get security policy for tenant\n    SELECT sp.* INTO v_policy\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h hp ON sp.security_policy_hk = hp.security_policy_hk\n    WHERE hp.tenant_hk = p_tenant_hk\n    AND sp.is_active = TRUE\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n    \n    -- If no policy found, use defaults\n    IF v_policy.security_policy_hk IS NULL THEN\n        v_policy.password_min_length := 8;\n        v_policy.password_require_uppercase := TRUE;\n        v_policy.password_require_lowercase := TRUE;\n        v_policy.password_require_number := TRUE;\n        v_policy.password_require_special := TRUE;\n    END IF;\n    \n    -- Validate password length\n    IF LENGTH(p_password) < v_policy.password_min_length THEN\n        v_violations := array_append(v_violations, \n            format('Password must be at least %s characters long', v_policy.password_min_length));\n        v_recommendations := array_append(v_recommendations, \n            format('Add %s more characters to meet minimum length requirement', \n                   v_policy.password_min_length - LENGTH(p_password)));\n        v_score := v_score - 30;\n    END IF;\n    \n    -- Validate uppercase requirement\n    IF v_policy.password_require_uppercase AND NOT (p_password ~ '[A-Z]') THEN\n        v_violations := array_append(v_violations, 'Password must contain at least one uppercase letter');\n        v_recommendations := array_append(v_recommendations, 'Add at least one uppercase letter (A-Z)');\n        v_score := v_score - 20;\n    END IF;\n    \n    -- Validate lowercase requirement\n    IF v_policy.password_require_lowercase AND NOT (p_password ~ '[a-z]') THEN\n        v_violations := array_append(v_violations, 'Password must contain at least one lowercase letter');\n        v_recommendations := array_append(v_recommendations, 'Add at least one lowercase letter (a-z)');\n        v_score := v_score - 20;\n    END IF;\n    \n    -- Validate number requirement\n    IF v_policy.password_require_number AND NOT (p_password ~ '[0-9]') THEN\n        v_violations := array_append(v_violations, 'Password must contain at least one number');\n        v_recommendations := array_append(v_recommendations, 'Add at least one number (0-9)');\n        v_score := v_score - 20;\n    END IF;\n    \n    -- Validate special character requirement\n    IF v_policy.password_require_special AND NOT (p_password ~ '[^A-Za-z0-9]') THEN\n        v_violations := array_append(v_violations, 'Password must contain at least one special character');\n        v_recommendations := array_append(v_recommendations, 'Add at least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)');\n        v_score := v_score - 20;\n    END IF;\n    \n    -- Additional strength checks\n    IF LENGTH(p_password) >= 16 THEN\n        v_score := v_score + 10; -- Bonus for long passwords\n    END IF;\n    \n    IF p_password ~ '.*(.)\\1{2,}.*' THEN\n        v_violations := array_append(v_violations, 'Password should not contain repeated characters');\n        v_recommendations := array_append(v_recommendations, 'Avoid using the same character more than twice in a row');\n        v_score := v_score - 10;\n    END IF;\n    \n    -- Ensure score doesn't go below 0\n    v_score := GREATEST(v_score, 0);\n    \n    RETURN QUERY SELECT \n        array_length(v_violations, 1) IS NULL,\n        v_score,\n        v_violations,\n        v_recommendations;\nEND;\n",
        null,
        "VALIDATION"
      ]
    ],
    "api_auth_functions": [
      [
        "api",
        "auth_complete_login",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        null,
        "API_AUTHENTICATION"
      ],
      [
        "api",
        "auth_login",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        null,
        "API_AUTHENTICATION"
      ],
      [
        "api",
        "auth_login_test",
        "p_username text, p_password text",
        "jsonb",
        "plpgsql",
        null,
        "API_AUTHENTICATION"
      ],
      [
        "api",
        "auth_logout",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        null,
        "API_AUTHENTICATION"
      ],
      [
        "api",
        "auth_validate_session",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        null,
        "API_AUTHENTICATION"
      ],
      [
        "api",
        "test_auth_with_roles",
        "",
        "jsonb",
        "plpgsql",
        null,
        "API_AUTHENTICATION"
      ],
      [
        "api",
        "ai_create_session",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        null,
        "API_SESSION"
      ],
      [
        "api",
        "token_validate",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        null,
        "API_TOKEN_MANAGEMENT"
      ],
      [
        "api",
        "tokens_generate",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        null,
        "API_TOKEN_MANAGEMENT"
      ],
      [
        "api",
        "tokens_revoke",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        null,
        "API_TOKEN_MANAGEMENT"
      ],
      [
        "api",
        "tokens_validate",
        "p_request jsonb",
        "jsonb",
        "plpgsql",
        null,
        "API_TOKEN_MANAGEMENT"
      ],
      [
        "api",
        "validate_contract",
        "",
        "jsonb",
        "plpgsql",
        null,
        "API_VALIDATION"
      ],
      [
        "api",
        "validate_fixed_contract",
        "",
        "jsonb",
        "plpgsql",
        null,
        "API_VALIDATION"
      ],
      [
        "api",
        "validate_secure_contract",
        "",
        "jsonb",
        "plpgsql",
        null,
        "API_VALIDATION"
      ]
    ],
    "security_policies": [
      [
        "api_token_h",
        "137891_138843_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "api_token_h",
        "137891_138843_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "api_token_bk IS NOT NULL"
      ],
      [
        "api_token_h",
        "137891_138843_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "api_token_h",
        "137891_138843_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "api_token_hk IS NOT NULL"
      ],
      [
        "api_token_h",
        "api_token_h_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "api_token_h",
        "uk_api_token_h_bk_tenant",
        "UNIQUE",
        "NO",
        "NO",
        null
      ],
      [
        "api_token_s",
        "137891_138859_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "api_token_s",
        "137891_138859_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "token_hash IS NOT NULL"
      ],
      [
        "api_token_s",
        "137891_138859_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "api_token_s",
        "137891_138859_6_not_null",
        "CHECK",
        "NO",
        "NO",
        "token_type IS NOT NULL"
      ],
      [
        "api_token_s",
        "137891_138859_7_not_null",
        "CHECK",
        "NO",
        "NO",
        "expires_at IS NOT NULL"
      ],
      [
        "api_token_s",
        "137891_138859_8_not_null",
        "CHECK",
        "NO",
        "NO",
        "is_revoked IS NOT NULL"
      ],
      [
        "api_token_s",
        "137891_138859_10_not_null",
        "CHECK",
        "NO",
        "NO",
        "scope IS NOT NULL"
      ],
      [
        "api_token_s",
        "chk_load_end_date",
        "CHECK",
        "NO",
        "NO",
        "((load_end_date IS NULL) OR (load_end_date > load_date))"
      ],
      [
        "api_token_s",
        "chk_revocation_logic",
        "CHECK",
        "NO",
        "NO",
        "(((is_revoked = false) AND (revoked_by IS NULL) AND (revoked_at IS NULL)) OR ((is_revoked = true) AND (revoked_by IS NOT NULL) AND (revoked_at IS NOT NULL)))"
      ],
      [
        "api_token_s",
        "chk_token_type",
        "CHECK",
        "NO",
        "NO",
        "((token_type)::text = ANY ((ARRAY['SESSION'::character varying, 'API_KEY'::character varying, 'REFRESH'::character varying, 'TEMPORARY'::character varying])::text[]))"
      ],
      [
        "api_token_s",
        "137891_138859_15_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "api_token_s",
        "137891_138859_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "api_token_hk IS NOT NULL"
      ],
      [
        "api_token_s",
        "api_token_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "ip_tracking_s",
        "137891_138959_8_not_null",
        "CHECK",
        "NO",
        "NO",
        "last_request_time IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "137891_138959_11_not_null",
        "CHECK",
        "NO",
        "NO",
        "suspicious_activity_flag IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "137891_138959_14_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "chk_request_times",
        "CHECK",
        "NO",
        "NO",
        "(last_request_time >= first_request_time)"
      ],
      [
        "ip_tracking_s",
        "chk_request_count",
        "CHECK",
        "NO",
        "NO",
        "(request_count > 0)"
      ],
      [
        "ip_tracking_s",
        "chk_load_end_date_ip",
        "CHECK",
        "NO",
        "NO",
        "((load_end_date IS NULL) OR (load_end_date > load_date))"
      ],
      [
        "ip_tracking_s",
        "137891_138959_6_not_null",
        "CHECK",
        "NO",
        "NO",
        "request_count IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "137891_138959_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "ip_address IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "137891_138959_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "137891_138959_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "chk_block_reason",
        "CHECK",
        "NO",
        "NO",
        "(((is_blocked = false) AND (block_reason IS NULL)) OR ((is_blocked = true) AND (block_reason IS NOT NULL)))"
      ],
      [
        "ip_tracking_s",
        "137891_138959_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "security_tracking_hk IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "137891_138959_7_not_null",
        "CHECK",
        "NO",
        "NO",
        "first_request_time IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "137891_138959_9_not_null",
        "CHECK",
        "NO",
        "NO",
        "is_blocked IS NOT NULL"
      ],
      [
        "ip_tracking_s",
        "ip_tracking_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "role_definition_s",
        "137891_138067_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "role_definition_s",
        "137891_138067_11_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "role_definition_s",
        "137891_138067_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "role_hk IS NOT NULL"
      ],
      [
        "role_definition_s",
        "137891_138067_8_not_null",
        "CHECK",
        "NO",
        "NO",
        "permissions IS NOT NULL"
      ],
      [
        "role_definition_s",
        "137891_138067_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "role_definition_s",
        "137891_138067_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "role_name IS NOT NULL"
      ],
      [
        "role_definition_s",
        "role_definition_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "role_h",
        "137891_138054_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "role_h",
        "137891_138054_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "role_h",
        "137891_138054_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "role_hk IS NOT NULL"
      ],
      [
        "role_h",
        "137891_138054_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "role_bk IS NOT NULL"
      ],
      [
        "role_h",
        "role_h_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "security_policy_h",
        "137891_138159_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "security_policy_h",
        "137891_138159_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "security_policy_h",
        "137891_138159_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "security_policy_hk IS NOT NULL"
      ],
      [
        "security_policy_h",
        "137891_138159_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "security_policy_bk IS NOT NULL"
      ],
      [
        "security_policy_h",
        "security_policy_h_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "security_policy_s",
        "137891_138172_21_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "security_policy_s",
        "137891_138172_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "policy_name IS NOT NULL"
      ],
      [
        "security_policy_s",
        "137891_138172_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "security_policy_hk IS NOT NULL"
      ],
      [
        "security_policy_s",
        "137891_138172_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "security_policy_s",
        "137891_138172_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "security_policy_s",
        "security_policy_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "security_tracking_h",
        "137891_138943_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "security_tracking_hk IS NOT NULL"
      ],
      [
        "security_tracking_h",
        "137891_138943_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "security_tracking_h",
        "137891_138943_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "security_tracking_h",
        "137891_138943_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "security_tracking_bk IS NOT NULL"
      ],
      [
        "security_tracking_h",
        "security_tracking_h_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "security_tracking_h",
        "uk_security_tracking_h_bk_tenant",
        "UNIQUE",
        "NO",
        "NO",
        null
      ],
      [
        "session_h",
        "137891_138107_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "session_h",
        "137891_138107_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "session_h",
        "137891_138107_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_hk IS NOT NULL"
      ],
      [
        "session_h",
        "137891_138107_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_bk IS NOT NULL"
      ],
      [
        "session_h",
        "session_h_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "session_state_s",
        "137891_138120_12_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "session_state_s",
        "137891_138120_10_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_status IS NOT NULL"
      ],
      [
        "session_state_s",
        "137891_138120_7_not_null",
        "CHECK",
        "NO",
        "NO",
        "ip_address IS NOT NULL"
      ],
      [
        "session_state_s",
        "137891_138120_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_start IS NOT NULL"
      ],
      [
        "session_state_s",
        "137891_138120_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "session_state_s",
        "137891_138120_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "session_state_s",
        "137891_138120_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_hk IS NOT NULL"
      ],
      [
        "session_state_s",
        "137891_138120_11_not_null",
        "CHECK",
        "NO",
        "NO",
        "last_activity IS NOT NULL"
      ],
      [
        "session_state_s",
        "session_state_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "session_token_l",
        "137891_138902_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "session_token_l",
        "137891_138902_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_token_hk IS NOT NULL"
      ],
      [
        "session_token_l",
        "137891_138902_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_hk IS NOT NULL"
      ],
      [
        "session_token_l",
        "137891_138902_6_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "session_token_l",
        "137891_138902_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "api_token_hk IS NOT NULL"
      ],
      [
        "session_token_l",
        "session_token_l_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "tenant_definition_s",
        "chk_compliance_level",
        "CHECK",
        "NO",
        "NO",
        "((compliance_level)::text = ANY ((ARRAY['BASIC'::character varying, 'STANDARD'::character varying, 'HIPAA'::character varying, 'SOX'::character varying, 'GDPR'::character varying])::text[]))"
      ],
      [
        "tenant_definition_s",
        "137891_142025_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "tenant_definition_s",
        "137891_142025_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "tenant_definition_s",
        "137891_142025_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "tenant_definition_s",
        "137891_142025_6_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_name IS NOT NULL"
      ],
      [
        "tenant_definition_s",
        "137891_142025_9_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_status IS NOT NULL"
      ],
      [
        "tenant_definition_s",
        "chk_load_end_date",
        "CHECK",
        "NO",
        "NO",
        "((load_end_date IS NULL) OR (load_end_date > load_date))"
      ],
      [
        "tenant_definition_s",
        "chk_positive_limits",
        "CHECK",
        "NO",
        "NO",
        "((max_users > 0) AND (max_storage_gb > 0) AND (data_retention_days > 0))"
      ],
      [
        "tenant_definition_s",
        "chk_subscription_dates",
        "CHECK",
        "NO",
        "NO",
        "((subscription_end_date IS NULL) OR (subscription_end_date > subscription_start_date))"
      ],
      [
        "tenant_definition_s",
        "chk_subscription_level",
        "CHECK",
        "NO",
        "NO",
        "((subscription_level)::text = ANY ((ARRAY['TRIAL'::character varying, 'STANDARD'::character varying, 'PREMIUM'::character varying, 'ENTERPRISE'::character varying])::text[]))"
      ],
      [
        "tenant_definition_s",
        "chk_tenant_status",
        "CHECK",
        "NO",
        "NO",
        "((tenant_status)::text = ANY ((ARRAY['ACTIVE'::character varying, 'INACTIVE'::character varying, 'SUSPENDED'::character varying, 'PENDING'::character varying])::text[]))"
      ],
      [
        "tenant_definition_s",
        "137891_142025_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "tenant_definition_s",
        "tenant_definition_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "tenant_h",
        "137891_137983_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "tenant_h",
        "137891_137983_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_bk IS NOT NULL"
      ],
      [
        "tenant_h",
        "137891_137983_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "tenant_h",
        "tenant_h_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "tenant_profile_s",
        "137891_137991_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "tenant_profile_s",
        "137891_137991_15_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "tenant_profile_s",
        "137891_137991_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_name IS NOT NULL"
      ],
      [
        "tenant_profile_s",
        "137891_137991_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "tenant_profile_s",
        "137891_137991_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "tenant_profile_s",
        "tenant_profile_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "token_activity_s",
        "137891_138926_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "api_token_hk IS NOT NULL"
      ],
      [
        "token_activity_s",
        "chk_activity_type",
        "CHECK",
        "NO",
        "NO",
        "((activity_type)::text = ANY ((ARRAY['CREATION'::character varying, 'VALIDATION'::character varying, 'API_ACCESS'::character varying, 'REVOCATION'::character varying, 'EXPIRATION'::character varying])::text[]))"
      ],
      [
        "token_activity_s",
        "chk_load_end_date_activity",
        "CHECK",
        "NO",
        "NO",
        "((load_end_date IS NULL) OR (load_end_date > load_date))"
      ],
      [
        "token_activity_s",
        "chk_response_status",
        "CHECK",
        "NO",
        "NO",
        "((response_status IS NULL) OR ((response_status >= 100) AND (response_status < 600)))"
      ],
      [
        "token_activity_s",
        "137891_138926_13_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "token_activity_s",
        "137891_138926_6_not_null",
        "CHECK",
        "NO",
        "NO",
        "activity_type IS NOT NULL"
      ],
      [
        "token_activity_s",
        "137891_138926_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "last_activity_timestamp IS NOT NULL"
      ],
      [
        "token_activity_s",
        "137891_138926_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "token_activity_s",
        "137891_138926_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "token_activity_s",
        "token_activity_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "user_auth_s",
        "137891_138036_6_not_null",
        "CHECK",
        "NO",
        "NO",
        "password_hash IS NOT NULL"
      ],
      [
        "user_auth_s",
        "137891_138036_16_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "user_auth_s",
        "137891_138036_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "user_hk IS NOT NULL"
      ],
      [
        "user_auth_s",
        "137891_138036_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "user_auth_s",
        "137891_138036_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "user_auth_s",
        "137891_138036_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "username IS NOT NULL"
      ],
      [
        "user_auth_s",
        "137891_138036_7_not_null",
        "CHECK",
        "NO",
        "NO",
        "password_salt IS NOT NULL"
      ],
      [
        "user_auth_s",
        "user_auth_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "user_h",
        "137891_138007_5_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "user_h",
        "137891_138007_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "user_bk IS NOT NULL"
      ],
      [
        "user_h",
        "137891_138007_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "user_h",
        "137891_138007_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "user_hk IS NOT NULL"
      ],
      [
        "user_h",
        "user_h_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "user_profile_s",
        "137891_138020_7_not_null",
        "CHECK",
        "NO",
        "NO",
        "email IS NOT NULL"
      ],
      [
        "user_profile_s",
        "137891_138020_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "user_profile_s",
        "137891_138020_14_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "user_profile_s",
        "137891_138020_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "user_hk IS NOT NULL"
      ],
      [
        "user_profile_s",
        "137891_138020_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "user_profile_s",
        "user_profile_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "user_role_l",
        "137891_138083_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "role_hk IS NOT NULL"
      ],
      [
        "user_role_l",
        "137891_138083_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "user_role_l",
        "137891_138083_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "user_hk IS NOT NULL"
      ],
      [
        "user_role_l",
        "137891_138083_6_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "user_role_l",
        "137891_138083_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "link_user_role_hk IS NOT NULL"
      ],
      [
        "user_role_l",
        "user_role_l_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "user_session_h",
        "137891_141948_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "user_session_h",
        "137891_141948_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_token IS NOT NULL"
      ],
      [
        "user_session_h",
        "137891_141948_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "user_session_h",
        "137891_141948_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_hk IS NOT NULL"
      ],
      [
        "user_session_h",
        "user_session_h_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "user_session_h",
        "user_session_h_session_token_key",
        "UNIQUE",
        "NO",
        "NO",
        null
      ],
      [
        "user_session_l",
        "137891_138133_6_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "user_session_l",
        "137891_138133_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "user_session_l",
        "137891_138133_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_hk IS NOT NULL"
      ],
      [
        "user_session_l",
        "137891_138133_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "user_hk IS NOT NULL"
      ],
      [
        "user_session_l",
        "137891_138133_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "link_user_session_hk IS NOT NULL"
      ],
      [
        "user_session_l",
        "user_session_l_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "user_session_s",
        "137891_141959_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "hash_diff IS NOT NULL"
      ],
      [
        "user_session_s",
        "137891_141959_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "load_date IS NOT NULL"
      ],
      [
        "user_session_s",
        "137891_141959_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "session_hk IS NOT NULL"
      ],
      [
        "user_session_s",
        "137891_141959_8_not_null",
        "CHECK",
        "NO",
        "NO",
        "expires_at IS NOT NULL"
      ],
      [
        "user_session_s",
        "137891_141959_9_not_null",
        "CHECK",
        "NO",
        "NO",
        "is_active IS NOT NULL"
      ],
      [
        "user_session_s",
        "137891_141959_10_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "user_session_s",
        "137891_141959_7_not_null",
        "CHECK",
        "NO",
        "NO",
        "created_at IS NOT NULL"
      ],
      [
        "user_session_s",
        "user_session_s_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ],
      [
        "user_token_l",
        "137891_138878_2_not_null",
        "CHECK",
        "NO",
        "NO",
        "user_hk IS NOT NULL"
      ],
      [
        "user_token_l",
        "137891_138878_4_not_null",
        "CHECK",
        "NO",
        "NO",
        "tenant_hk IS NOT NULL"
      ],
      [
        "user_token_l",
        "137891_138878_3_not_null",
        "CHECK",
        "NO",
        "NO",
        "api_token_hk IS NOT NULL"
      ],
      [
        "user_token_l",
        "137891_138878_1_not_null",
        "CHECK",
        "NO",
        "NO",
        "user_token_hk IS NOT NULL"
      ],
      [
        "user_token_l",
        "137891_138878_6_not_null",
        "CHECK",
        "NO",
        "NO",
        "record_source IS NOT NULL"
      ],
      [
        "user_token_l",
        "user_token_l_pkey",
        "PRIMARY KEY",
        "NO",
        "NO",
        null
      ]
    ],
    "rls_policies": [],
    "auth_indexes": [
      [
        "auth",
        "api_token_h",
        "api_token_h_pkey",
        "CREATE UNIQUE INDEX api_token_h_pkey ON auth.api_token_h USING btree (api_token_hk)",
        true,
        true
      ],
      [
        "auth",
        "api_token_h",
        "idx_api_token_h_tenant_bk",
        "CREATE INDEX idx_api_token_h_tenant_bk ON auth.api_token_h USING btree (tenant_hk, api_token_bk)",
        false,
        false
      ],
      [
        "auth",
        "api_token_h",
        "uk_api_token_h_bk_tenant",
        "CREATE UNIQUE INDEX uk_api_token_h_bk_tenant ON auth.api_token_h USING btree (api_token_bk, tenant_hk)",
        true,
        false
      ],
      [
        "auth",
        "api_token_s",
        "api_token_s_pkey",
        "CREATE UNIQUE INDEX api_token_s_pkey ON auth.api_token_s USING btree (api_token_hk, load_date)",
        true,
        true
      ],
      [
        "auth",
        "api_token_s",
        "idx_api_token_s_expires_at_active",
        "CREATE INDEX idx_api_token_s_expires_at_active ON auth.api_token_s USING btree (expires_at) WHERE ((load_end_date IS NULL) AND (is_revoked = false))",
        false,
        false
      ],
      [
        "auth",
        "api_token_s",
        "idx_api_token_s_hk_type_active",
        "CREATE INDEX idx_api_token_s_hk_type_active ON auth.api_token_s USING btree (api_token_hk, token_type) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "api_token_s",
        "idx_api_token_s_token_hash_active",
        "CREATE INDEX idx_api_token_s_token_hash_active ON auth.api_token_s USING btree (token_hash) WHERE ((load_end_date IS NULL) AND (is_revoked = false))",
        false,
        false
      ],
      [
        "auth",
        "api_token_s",
        "idx_api_token_s_type_active",
        "CREATE INDEX idx_api_token_s_type_active ON auth.api_token_s USING btree (token_type) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "session_h",
        "idx_session_h_session_bk",
        "CREATE INDEX idx_session_h_session_bk ON auth.session_h USING btree (session_bk)",
        false,
        false
      ],
      [
        "auth",
        "session_h",
        "session_h_pkey",
        "CREATE UNIQUE INDEX session_h_pkey ON auth.session_h USING btree (session_hk)",
        true,
        true
      ],
      [
        "auth",
        "session_state_s",
        "idx_session_state_s_activity_optimized",
        "CREATE INDEX idx_session_state_s_activity_optimized ON auth.session_state_s USING btree (session_hk, session_status, last_activity DESC) WHERE ((load_end_date IS NULL) AND ((session_status)::text = 'ACTIVE'::text))",
        false,
        false
      ],
      [
        "auth",
        "session_state_s",
        "idx_session_state_s_last_activity",
        "CREATE INDEX idx_session_state_s_last_activity ON auth.session_state_s USING btree (last_activity)",
        false,
        false
      ],
      [
        "auth",
        "session_state_s",
        "idx_session_state_s_last_activity_step13",
        "CREATE INDEX idx_session_state_s_last_activity_step13 ON auth.session_state_s USING btree (session_hk, last_activity) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "session_state_s",
        "idx_session_state_s_session_start_step13",
        "CREATE INDEX idx_session_state_s_session_start_step13 ON auth.session_state_s USING btree (session_hk, session_start) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "session_state_s",
        "idx_session_state_s_status",
        "CREATE INDEX idx_session_state_s_status ON auth.session_state_s USING btree (session_status)",
        false,
        false
      ],
      [
        "auth",
        "session_state_s",
        "session_state_s_pkey",
        "CREATE UNIQUE INDEX session_state_s_pkey ON auth.session_state_s USING btree (session_hk, load_date)",
        true,
        true
      ],
      [
        "auth",
        "session_token_l",
        "idx_session_token_l_session",
        "CREATE INDEX idx_session_token_l_session ON auth.session_token_l USING btree (session_hk)",
        false,
        false
      ],
      [
        "auth",
        "session_token_l",
        "idx_session_token_l_token",
        "CREATE INDEX idx_session_token_l_token ON auth.session_token_l USING btree (api_token_hk)",
        false,
        false
      ],
      [
        "auth",
        "session_token_l",
        "session_token_l_pkey",
        "CREATE UNIQUE INDEX session_token_l_pkey ON auth.session_token_l USING btree (session_token_hk)",
        true,
        true
      ],
      [
        "auth",
        "token_activity_s",
        "idx_token_activity_s_timestamp_active",
        "CREATE INDEX idx_token_activity_s_timestamp_active ON auth.token_activity_s USING btree (last_activity_timestamp DESC) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "token_activity_s",
        "token_activity_s_pkey",
        "CREATE UNIQUE INDEX token_activity_s_pkey ON auth.token_activity_s USING btree (api_token_hk, load_date)",
        true,
        true
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_current_record",
        "CREATE UNIQUE INDEX idx_user_auth_current_record ON auth.user_auth_s USING btree (user_hk) WHERE (load_end_date IS NULL)",
        true,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_s_account_locked",
        "CREATE INDEX idx_user_auth_s_account_locked ON auth.user_auth_s USING btree (account_locked) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_s_account_locked_step13",
        "CREATE INDEX idx_user_auth_s_account_locked_step13 ON auth.user_auth_s USING btree (account_locked, account_locked_until) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_s_failed_attempts_step13",
        "CREATE INDEX idx_user_auth_s_failed_attempts_step13 ON auth.user_auth_s USING btree (user_hk, failed_login_attempts) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_s_last_login",
        "CREATE INDEX idx_user_auth_s_last_login ON auth.user_auth_s USING btree (last_login_date) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_s_username",
        "CREATE INDEX idx_user_auth_s_username ON auth.user_auth_s USING btree (username) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_s_username_current",
        "CREATE INDEX idx_user_auth_s_username_current ON auth.user_auth_s USING btree (username) WHERE ((load_end_date IS NULL) AND (account_locked = false))",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_s_username_optimized",
        "CREATE INDEX idx_user_auth_s_username_optimized ON auth.user_auth_s USING btree (username, load_date DESC) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_s_username_tenant",
        "CREATE INDEX idx_user_auth_s_username_tenant ON auth.user_auth_s USING btree (username) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_tenant_username",
        "CREATE INDEX idx_user_auth_tenant_username ON auth.user_auth_s USING btree (username, user_hk) INCLUDE (password_hash, account_locked, failed_login_attempts) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_username",
        "CREATE INDEX idx_user_auth_username ON auth.user_auth_s USING btree (username) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_username_lookup",
        "CREATE INDEX idx_user_auth_username_lookup ON auth.user_auth_s USING btree (username, load_date DESC) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "idx_user_auth_username_unique",
        "CREATE UNIQUE INDEX idx_user_auth_username_unique ON auth.user_auth_s USING btree (user_hk, username) WHERE (load_end_date IS NULL)",
        true,
        false
      ],
      [
        "auth",
        "user_auth_s",
        "user_auth_s_pkey",
        "CREATE UNIQUE INDEX user_auth_s_pkey ON auth.user_auth_s USING btree (user_hk, load_date)",
        true,
        true
      ],
      [
        "auth",
        "user_h",
        "idx_user_h_tenant_hk",
        "CREATE INDEX idx_user_h_tenant_hk ON auth.user_h USING btree (tenant_hk)",
        false,
        false
      ],
      [
        "auth",
        "user_h",
        "idx_user_h_tenant_user_optimized",
        "CREATE INDEX idx_user_h_tenant_user_optimized ON auth.user_h USING btree (tenant_hk, user_hk)",
        false,
        false
      ],
      [
        "auth",
        "user_h",
        "user_h_pkey",
        "CREATE UNIQUE INDEX user_h_pkey ON auth.user_h USING btree (user_hk)",
        true,
        true
      ],
      [
        "auth",
        "user_profile_s",
        "idx_user_profile_s_email",
        "CREATE INDEX idx_user_profile_s_email ON auth.user_profile_s USING btree (email) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_profile_s",
        "idx_user_profile_s_email_active",
        "CREATE INDEX idx_user_profile_s_email_active ON auth.user_profile_s USING btree (email) WHERE ((load_end_date IS NULL) AND (is_active = true))",
        false,
        false
      ],
      [
        "auth",
        "user_profile_s",
        "idx_user_profile_s_is_active",
        "CREATE INDEX idx_user_profile_s_is_active ON auth.user_profile_s USING btree (is_active) WHERE (load_end_date IS NULL)",
        false,
        false
      ],
      [
        "auth",
        "user_profile_s",
        "user_profile_s_pkey",
        "CREATE UNIQUE INDEX user_profile_s_pkey ON auth.user_profile_s USING btree (user_hk, load_date)",
        true,
        true
      ],
      [
        "auth",
        "user_role_l",
        "idx_user_role_l_user_hk",
        "CREATE INDEX idx_user_role_l_user_hk ON auth.user_role_l USING btree (user_hk)",
        false,
        false
      ],
      [
        "auth",
        "user_role_l",
        "user_role_l_pkey",
        "CREATE UNIQUE INDEX user_role_l_pkey ON auth.user_role_l USING btree (link_user_role_hk)",
        true,
        true
      ],
      [
        "auth",
        "user_session_h",
        "user_session_h_pkey",
        "CREATE UNIQUE INDEX user_session_h_pkey ON auth.user_session_h USING btree (session_hk)",
        true,
        true
      ],
      [
        "auth",
        "user_session_h",
        "user_session_h_session_token_key",
        "CREATE UNIQUE INDEX user_session_h_session_token_key ON auth.user_session_h USING btree (session_token)",
        true,
        false
      ],
      [
        "auth",
        "user_session_l",
        "idx_user_session_l_user_hk",
        "CREATE INDEX idx_user_session_l_user_hk ON auth.user_session_l USING btree (user_hk)",
        false,
        false
      ],
      [
        "auth",
        "user_session_l",
        "idx_user_session_l_user_tenant_optimized",
        "CREATE INDEX idx_user_session_l_user_tenant_optimized ON auth.user_session_l USING btree (user_hk, tenant_hk, load_date DESC)",
        false,
        false
      ],
      [
        "auth",
        "user_session_l",
        "user_session_l_pkey",
        "CREATE UNIQUE INDEX user_session_l_pkey ON auth.user_session_l USING btree (link_user_session_hk)",
        true,
        true
      ],
      [
        "auth",
        "user_session_s",
        "user_session_s_pkey",
        "CREATE UNIQUE INDEX user_session_s_pkey ON auth.user_session_s USING btree (session_hk, load_date)",
        true,
        true
      ],
      [
        "auth",
        "user_token_l",
        "idx_user_token_l_token",
        "CREATE INDEX idx_user_token_l_token ON auth.user_token_l USING btree (api_token_hk)",
        false,
        false
      ],
      [
        "auth",
        "user_token_l",
        "idx_user_token_l_user",
        "CREATE INDEX idx_user_token_l_user ON auth.user_token_l USING btree (user_hk)",
        false,
        false
      ],
      [
        "auth",
        "user_token_l",
        "user_token_l_pkey",
        "CREATE UNIQUE INDEX user_token_l_pkey ON auth.user_token_l USING btree (user_token_hk)",
        true,
        true
      ]
    ],
    "token_validation": [
      [
        "auth_validate_session",
        "\nDECLARE\n    v_session_token TEXT;\n    v_ip_address INET;\n    v_user_agent TEXT;\n    v_validation_result RECORD;\nBEGIN\n    -- Extract parameters\n    v_session_token := p_request->>'session_token';\n    v_ip_address := (p_request->>'ip_address')::INET;\n    v_user_agent := p_request->>'user_agent';\n    \n    -- Validate required parameters\n    IF v_session_token IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Session token is required',\n            'error_code', 'MISSING_TOKEN'\n        );\n    END IF;\n    \n    -- For now, implement basic validation\n    -- In production, this would validate against session tables\n    IF length(v_session_token) >= 32 THEN\n        RETURN jsonb_build_object(\n            'success', true,\n            'message', 'Session is valid',\n            'data', jsonb_build_object(\n                'user_id', 'validated_user',\n                'tenant_id', 'validated_tenant',\n                'expires_at', CURRENT_TIMESTAMP + INTERVAL '2 hours'\n            )\n        );\n    ELSE\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Invalid session token',\n            'error_code', 'INVALID_TOKEN'\n        );\n    END IF;\nEND;\n"
      ],
      [
        "token_validate",
        "\nDECLARE\n    v_token TEXT;\n    v_ip_address INET;\n    v_user_agent TEXT;\n    v_endpoint VARCHAR(500);\n    v_validation_result RECORD;\nBEGIN\n    -- Extract parameters\n    v_token := p_request->>'token';\n    v_ip_address := (p_request->>'ip_address')::INET;\n    v_user_agent := p_request->>'user_agent';\n    v_endpoint := p_request->>'endpoint';\n    \n    -- Validate required parameters\n    IF v_token IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Token is required',\n            'error_code', 'MISSING_TOKEN'\n        );\n    END IF;\n    \n    -- Call the enhanced validation function\n    SELECT * INTO v_validation_result\n    FROM auth.validate_token_and_session(\n        v_token,\n        v_ip_address,\n        v_user_agent,\n        v_endpoint\n    );\n    \n    RETURN jsonb_build_object(\n        'success', COALESCE(v_validation_result.is_valid, false),\n        'message', COALESCE(v_validation_result.message, 'Token validation failed'),\n        'data', CASE \n            WHEN v_validation_result.is_valid THEN\n                jsonb_build_object(\n                    'user_hk', encode(v_validation_result.user_hk, 'hex'),\n                    'session_hk', encode(v_validation_result.session_hk, 'hex')\n                )\n            ELSE NULL\n        END\n    );\nEND;\n"
      ],
      [
        "tokens_generate",
        "\nDECLARE\n    v_session_token TEXT;\n    v_token_type VARCHAR(50);\n    v_expires_in INTEGER;\n    v_new_token TEXT;\n    v_expires_at TIMESTAMP WITH TIME ZONE;\nBEGIN\n    -- Extract parameters\n    v_session_token := p_request->>'session_token';\n    v_token_type := COALESCE(p_request->>'token_type', 'API');\n    v_expires_in := COALESCE((p_request->>'expires_in')::INTEGER, 3600); -- default 1 hour\n    \n    -- Validate session token\n    IF v_session_token IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Session token required',\n            'error_code', 'MISSING_TOKEN'\n        );\n    END IF;\n    \n    -- Generate new token\n    v_new_token := encode(gen_random_bytes(32), 'hex');\n    v_expires_at := CURRENT_TIMESTAMP + (v_expires_in || ' seconds')::INTERVAL;\n    \n    RETURN jsonb_build_object(\n        'success', true,\n        'message', 'Token generated successfully',\n        'data', jsonb_build_object(\n            'token', v_new_token,\n            'token_type', v_token_type,\n            'expires_at', v_expires_at,\n            'expires_in', v_expires_in\n        )\n    );\nEND;\n"
      ],
      [
        "tokens_revoke",
        "\nDECLARE\n    v_token TEXT;\n    v_reason TEXT;\nBEGIN\n    -- Extract parameters\n    v_token := p_request->>'token';\n    v_reason := COALESCE(p_request->>'reason', 'User requested revocation');\n    \n    -- Validate required parameters\n    IF v_token IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Token is required',\n            'error_code', 'MISSING_TOKEN'\n        );\n    END IF;\n    \n    -- For now, always return success\n    -- In production, this would revoke the token in the database\n    RETURN jsonb_build_object(\n        'success', true,\n        'message', 'Token revoked successfully',\n        'data', jsonb_build_object(\n            'revoked_at', CURRENT_TIMESTAMP,\n            'reason', v_reason\n        )\n    );\nEND;\n"
      ],
      [
        "tokens_validate",
        "\nDECLARE\n    v_token TEXT;\n    v_ip_address INET;\n    v_user_agent TEXT;\nBEGIN\n    -- Extract parameters\n    v_token := p_request->>'token';\n    v_ip_address := (p_request->>'ip_address')::INET;\n    v_user_agent := p_request->>'user_agent';\n    \n    -- Validate required parameters\n    IF v_token IS NULL THEN\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Token is required',\n            'error_code', 'MISSING_TOKEN'\n        );\n    END IF;\n    \n    -- Basic token validation (length check)\n    IF length(v_token) >= 32 THEN\n        RETURN jsonb_build_object(\n            'success', true,\n            'message', 'Token is valid',\n            'data', jsonb_build_object(\n                'user_id', 'validated_user',\n                'tenant_id', 'validated_tenant',\n                'token_type', 'API',\n                'expires_at', CURRENT_TIMESTAMP + INTERVAL '1 hour'\n            )\n        );\n    ELSE\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Invalid token format',\n            'error_code', 'INVALID_TOKEN'\n        );\n    END IF;\nEND;\n"
      ],
      [
        "validate_contract",
        "\nDECLARE\n    v_functions TEXT[] := ARRAY[\n        'api.auth_login',\n        'api.auth_complete_login', \n        'api.auth_validate_session',\n        'api.tenant_register',\n        'api.user_register',\n        'api.token_validate',\n        'api.security_rate_limit_check'\n    ];\n    v_function TEXT;\n    v_exists BOOLEAN;\n    v_results JSONB := '[]'::JSONB;\nBEGIN\n    FOREACH v_function IN ARRAY v_functions\n    LOOP\n        SELECT EXISTS (\n            SELECT 1 FROM pg_proc p\n            JOIN pg_namespace n ON p.pronamespace = n.oid\n            WHERE n.nspname = split_part(v_function, '.', 1)\n            AND p.proname = split_part(v_function, '.', 2)\n        ) INTO v_exists;\n        \n        v_results := v_results || jsonb_build_object(\n            'function', v_function,\n            'exists', v_exists,\n            'status', CASE WHEN v_exists THEN 'OK' ELSE 'MISSING' END\n        );\n    END LOOP;\n    \n    RETURN jsonb_build_object(\n        'contract_validation', 'completed',\n        'timestamp', CURRENT_TIMESTAMP,\n        'functions', v_results\n    );\nEND;\n"
      ],
      [
        "validate_fixed_contract",
        "\nDECLARE\n    v_functions TEXT[] := ARRAY[\n        'api.auth_login',\n        'api.auth_validate_session',\n        'raw.capture_login_attempt',\n        'staging.validate_login_credentials',\n        'auth.create_session_with_token'\n    ];\n    v_function TEXT;\n    v_exists BOOLEAN;\n    v_results JSONB := '[]'::JSONB;\nBEGIN\n    FOREACH v_function IN ARRAY v_functions\n    LOOP\n        SELECT EXISTS (\n            SELECT 1 FROM pg_proc p\n            JOIN pg_namespace n ON p.pronamespace = n.oid\n            WHERE n.nspname = split_part(v_function, '.', 1)\n            AND p.proname = split_part(v_function, '.', 2)\n        ) INTO v_exists;\n        \n        v_results := v_results || jsonb_build_object(\n            'function', v_function,\n            'exists', v_exists,\n            'status', CASE WHEN v_exists THEN 'OK' ELSE 'MISSING' END\n        );\n    END LOOP;\n    \n    RETURN jsonb_build_object(\n        'contract_validation', 'Data Vault 2.0 Flow Fixed - No Redundant Code',\n        'timestamp', CURRENT_TIMESTAMP,\n        'functions', v_results,\n        'flow', 'Raw Schema \u2192 Staging Schema \u2192 Auth Schema (using existing procedures)',\n        'note', 'Uses existing auth.create_session_with_token - no redundant session creation'\n    );\nEND;\n"
      ],
      [
        "validate_secure_contract",
        "\nDECLARE\n    v_raw_function_exists BOOLEAN;\n    v_function_details RECORD;\n    v_retry_function_exists BOOLEAN;\nBEGIN\n    -- Check that we're using the secure raw.capture_login_attempt\n    SELECT \n        p.proname,\n        array_length(p.proargtypes, 1) as param_count,\n        pg_get_function_arguments(p.oid) as signature\n    INTO v_function_details\n    FROM pg_proc p\n    JOIN pg_namespace n ON p.pronamespace = n.oid\n    WHERE n.nspname = 'raw'\n    AND p.proname = 'capture_login_attempt';\n    \n    v_raw_function_exists := FOUND;\n    \n    -- Check for retry/lockout function\n    SELECT true INTO v_retry_function_exists\n    FROM pg_proc p\n    JOIN pg_namespace n ON p.pronamespace = n.oid\n    WHERE n.nspname = 'auth'\n    AND p.proname = 'process_failed_login';\n    \n    RETURN jsonb_build_object(\n        'security_validation', 'API-Level Password Validation with Retry Support - COMPLETE',\n        'timestamp', CURRENT_TIMESTAMP,\n        'raw_function_exists', v_raw_function_exists,\n        'retry_function_exists', COALESCE(v_retry_function_exists, false),\n        'function_signature', COALESCE(v_function_details.signature, 'NOT_FOUND'),\n        'security_note', 'Passwords validated at API level BEFORE any processing, never stored in raw schema',\n        'flow', 'API Validation (BLOCKING) \u2192 Raw Capture (secure) \u2192 Failed Login Processing \u2192 Retry Support \u2192 Session Creation (ONLY if valid)',\n        'critical_fix', 'Password validation blocks ALL subsequent processing + retry support with lockout protection',\n        'retry_features', jsonb_build_object(\n            'tracks_failed_attempts', true,\n            'provides_retry_feedback', true,\n            'implements_account_lockout', true,\n            'supports_lockout_expiration', true,\n            'resets_counter_on_success', true\n        )\n    );\nEND;\n"
      ],
      [
        "create_session_with_token",
        "\nDECLARE\n    v_tenant_hk BYTEA;\n    v_session_bk VARCHAR(255);\n    v_api_token_hk BYTEA;\n    v_security_policy auth.security_policy_s%ROWTYPE;\n    v_expires_at TIMESTAMP WITH TIME ZONE;\n    v_load_date TIMESTAMP WITH TIME ZONE;\n    v_record_source VARCHAR(100);\nBEGIN\n    -- Initialize operational variables\n    v_load_date := util.current_load_date();\n    v_record_source := util.get_record_source();\n    \n    -- Get tenant context\n    SELECT tenant_hk INTO v_tenant_hk\n    FROM auth.user_h\n    WHERE user_hk = p_user_hk;\n\n    IF v_tenant_hk IS NULL THEN\n        RAISE EXCEPTION 'User not found: %', encode(p_user_hk, 'hex');\n    END IF;\n\n    -- Get current security policy\n    SELECT sp.* INTO v_security_policy\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h hp ON sp.security_policy_hk = hp.security_policy_hk\n    WHERE hp.tenant_hk = v_tenant_hk\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n\n    -- Generate session business key and hash key\n    v_session_bk := util.generate_bk(encode(v_tenant_hk, 'hex') || '_SESSION_' || CURRENT_TIMESTAMP::text);\n    p_session_hk := util.hash_binary(v_session_bk);\n\n    -- Create session hub record\n    INSERT INTO auth.session_h (\n        session_hk,\n        session_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        p_session_hk,\n        v_session_bk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\n    -- Create session state satellite\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    ) VALUES (\n        p_session_hk,\n        v_load_date,\n        util.hash_binary(v_session_bk || 'ACTIVE' || p_ip_address::text),\n        CURRENT_TIMESTAMP,\n        p_ip_address,\n        p_user_agent,\n        jsonb_build_object(\n            'created_timestamp', CURRENT_TIMESTAMP,\n            'security_policy_applied', COALESCE(v_security_policy.policy_name, 'default')\n        ),\n        'ACTIVE',\n        CURRENT_TIMESTAMP,\n        v_record_source\n    );\n\n    -- Create user-session link\n    INSERT INTO auth.user_session_l (\n        link_user_session_hk,\n        user_hk,\n        session_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(p_user_hk::text || p_session_hk::text),\n        p_user_hk,\n        p_session_hk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\n    -- Generate associated API token\n    SELECT token_value, expires_at INTO p_token_value, v_expires_at\n    FROM auth.generate_api_token(\n        p_user_hk,\n        'SESSION',\n        ARRAY['api:access', 'session:maintain'],\n        COALESCE(v_security_policy.session_timeout_minutes, 60) * INTERVAL '1 minute'\n    );\n\n    -- Get token hash key for relationship creation\n    SELECT api_token_hk INTO v_api_token_hk\n    FROM auth.api_token_s\n    WHERE token_hash = util.hash_binary(p_token_value)\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    -- Create session-token relationship\n    INSERT INTO auth.session_token_l (\n        session_token_hk,\n        session_hk,\n        api_token_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(p_session_hk::text || v_api_token_hk::text),\n        p_session_hk,\n        v_api_token_hk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\nEND;\n"
      ],
      [
        "generate_api_token",
        "\nDECLARE\n    v_api_token_bk VARCHAR(255);\n    v_api_token_hk BYTEA;\n    v_tenant_hk BYTEA;\n    v_token_value TEXT;\n    v_expires_at TIMESTAMP WITH TIME ZONE;\n    v_token_hash BYTEA;\n    v_load_date TIMESTAMP WITH TIME ZONE;\n    v_record_source VARCHAR(100);\nBEGIN\n    -- Initialize operational variables\n    v_load_date := util.current_load_date();\n    v_record_source := util.get_record_source();\n    \n    -- Get tenant context from user\n    SELECT tenant_hk INTO v_tenant_hk\n    FROM auth.user_h\n    WHERE user_hk = p_user_hk;\n\n    IF v_tenant_hk IS NULL THEN\n        RAISE EXCEPTION 'User not found: %', encode(p_user_hk, 'hex');\n    END IF;\n\n    -- Generate cryptographically secure token\n    v_token_value := encode(gen_random_bytes(32), 'hex');\n    v_token_hash := util.hash_binary(v_token_value);\n    v_expires_at := CURRENT_TIMESTAMP + p_expires_in;\n\n    -- Create business key and hash key for token\n    v_api_token_bk := util.generate_bk(encode(v_tenant_hk, 'hex') || '_TOKEN_' || v_token_value);\n    v_api_token_hk := util.hash_binary(v_api_token_bk);\n\n    -- Create API token hub record\n    INSERT INTO auth.api_token_h (\n        api_token_hk,\n        api_token_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        v_api_token_bk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\n    -- Create API token satellite\n    INSERT INTO auth.api_token_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        scope,\n        created_by,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        v_load_date,\n        util.hash_binary(v_token_value || p_token_type || v_expires_at::text),\n        v_token_hash,\n        p_token_type,\n        v_expires_at,\n        FALSE,\n        p_scope,\n        SESSION_USER,\n        v_record_source\n    );\n\n    -- Create user-token link\n    INSERT INTO auth.user_token_l (\n        user_token_hk,\n        user_hk,\n        api_token_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(p_user_hk::text || v_api_token_hk::text),\n        p_user_hk,\n        v_api_token_hk,\n        v_tenant_hk,\n        v_load_date,\n        v_record_source\n    );\n\n    -- Create initial activity record\n    INSERT INTO auth.token_activity_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        last_activity_timestamp,\n        activity_type,\n        activity_metadata,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        v_load_date,\n        util.hash_binary('TOKEN_CREATION' || CURRENT_TIMESTAMP::text),\n        CURRENT_TIMESTAMP,\n        'CREATION',\n        jsonb_build_object(\n            'token_type', p_token_type,\n            'scope', p_scope,\n            'expires_at', v_expires_at,\n            'created_by', SESSION_USER\n        ),\n        v_record_source\n    );\n\n    -- Return token information\n    RETURN QUERY SELECT v_token_value, v_expires_at;\nEND;\n"
      ],
      [
        "generate_session_token",
        "\r\nBEGIN\r\n    -- Generate a 64-character hex token using timestamp + random\r\n    RETURN encode(\r\n        sha256(\r\n            (EXTRACT(EPOCH FROM CURRENT_TIMESTAMP)::text || encode(gen_random_bytes(32), 'hex'))::bytea\r\n        ), \r\n        'hex'\r\n    );\r\nEND;\r\n"
      ],
      [
        "generate_token_for_session",
        "\nDECLARE\n    v_user_hk BYTEA;\n    v_tenant_hk BYTEA;\n    v_token_hk BYTEA;\n    v_link_hk BYTEA;\n    v_security_policy auth.security_policy_s%ROWTYPE;\n    v_token_hash BYTEA;\n    v_expires_at TIMESTAMP WITH TIME ZONE;\n    v_timeout_minutes NUMERIC;\n    c_MAX_HIPAA_TIMEOUT CONSTANT NUMERIC := 20;  -- Maximum 20 minutes\n    c_MIN_HIPAA_TIMEOUT CONSTANT NUMERIC := 10;  -- Minimum 10 minutes\nBEGIN\n    -- Get user_hk from session with corrected table name\n    SELECT lus.user_hk INTO v_user_hk\n    FROM auth.user_session_l lus\n    WHERE lus.session_hk = p_session_hk;\n    \n    IF v_user_hk IS NULL THEN\n        RAISE EXCEPTION 'No user found for session';\n    END IF;\n    \n    -- Get tenant_hk from user with corrected table name\n    SELECT hu.tenant_hk INTO v_tenant_hk\n    FROM auth.user_h hu\n    WHERE hu.user_hk = v_user_hk;\n    \n    IF v_tenant_hk IS NULL THEN\n        RAISE EXCEPTION 'No tenant found for user';\n    END IF;\n    \n    -- Get security policy for tenant with corrected table names\n    SELECT sp.* INTO v_security_policy\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h hp ON sp.security_policy_hk = hp.security_policy_hk\n    WHERE hp.tenant_hk = v_tenant_hk\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n    \n    -- HIPAA-Compliant Timeout Calculation\n    v_timeout_minutes := COALESCE(\n        v_security_policy.session_timeout_minutes, \n        c_MAX_HIPAA_TIMEOUT\n    );\n    \n    -- Enforce minimum and maximum timeout\n    v_timeout_minutes := LEAST(\n        GREATEST(v_timeout_minutes, c_MIN_HIPAA_TIMEOUT), \n        c_MAX_HIPAA_TIMEOUT\n    );\n    \n    -- Calculate expires_at\n    v_expires_at := CURRENT_TIMESTAMP + (v_timeout_minutes * INTERVAL '1 minute');\n    \n    -- Generate token and its hash\n    v_token_hk := util.hash_binary(gen_random_uuid()::text);\n    v_token_hash := util.hash_binary(v_token_hk::text);\n    \n    -- First, insert into api_token_h with corrected table name\n    INSERT INTO auth.api_token_h (\n        token_hk,\n        token_bk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        v_token_hk,\n        encode(v_token_hk, 'hex'),\n        v_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    ) ON CONFLICT DO NOTHING;\n    \n    -- Then, insert into api_token_s with corrected table name\n    INSERT INTO auth.api_token_s (\n        token_hk,\n        load_date,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        scope,\n        record_source\n    ) VALUES (\n        v_token_hk,\n        util.current_load_date(),\n        util.hash_binary(v_token_hk::text),\n        v_token_hash,\n        'SESSION',\n        v_expires_at,\n        false,\n        ARRAY['api:access'],\n        util.get_record_source()\n    );\n    \n    -- Set output token value (this will be the token_hk)\n    p_token_value := encode(v_token_hk, 'hex');\n    \n    -- Create session-token link with corrected table name\n    v_link_hk := util.hash_binary(p_session_hk::text || v_token_hk::text);\n    \n    INSERT INTO auth.session_token_l (\n        link_session_token_hk,\n        session_hk,\n        token_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        v_link_hk,\n        p_session_hk,\n        v_token_hk,\n        v_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    ) ON CONFLICT DO NOTHING;\n\n    -- Link token to user with corrected table name\n    INSERT INTO auth.user_token_l (\n        link_user_token_hk,\n        user_hk,\n        token_hk,\n        tenant_hk,\n        load_date,\n        record_source\n    ) VALUES (\n        util.hash_binary(v_user_hk::text || v_token_hk::text),\n        v_user_hk,\n        v_token_hk,\n        v_tenant_hk,\n        util.current_load_date(),\n        util.get_record_source()\n    ) ON CONFLICT DO NOTHING;\n    \nEND;\n"
      ],
      [
        "revoke_token",
        "\nDECLARE\n    v_api_token_hk BYTEA;\n    v_current_token auth.api_token_s%ROWTYPE;\nBEGIN\n    -- Get current token details\n    SELECT * INTO v_current_token\n    FROM auth.api_token_s\n    WHERE token_hash = p_token_hash\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    IF NOT FOUND THEN\n        RETURN FALSE;\n    END IF;\n\n    v_api_token_hk := v_current_token.api_token_hk;\n\n    -- End current token record\n    UPDATE auth.api_token_s\n    SET load_end_date = util.current_load_date()\n    WHERE api_token_hk = v_api_token_hk\n    AND load_end_date IS NULL;\n\n    -- Create revoked token record\n    INSERT INTO auth.api_token_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        revocation_reason,\n        scope,\n        last_used_at,\n        created_by,\n        revoked_by,\n        revoked_at,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        util.current_load_date(),\n        util.hash_binary(v_current_token.token_hash::text || 'REVOKED' || p_reason),\n        v_current_token.token_hash,\n        v_current_token.token_type,\n        v_current_token.expires_at,\n        TRUE,\n        p_reason,\n        v_current_token.scope,\n        v_current_token.last_used_at,\n        v_current_token.created_by,\n        SESSION_USER,\n        CURRENT_TIMESTAMP,\n        util.get_record_source()\n    );\n\n    -- Record revocation activity\n    INSERT INTO auth.token_activity_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        last_activity_timestamp,\n        activity_type,\n        activity_metadata,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        util.current_load_date(),\n        util.hash_binary('TOKEN_REVOCATION' || CURRENT_TIMESTAMP::text),\n        CURRENT_TIMESTAMP,\n        'REVOCATION',\n        jsonb_build_object(\n            'revocation_reason', p_reason,\n            'revoked_by', SESSION_USER,\n            'revoked_at', CURRENT_TIMESTAMP\n        ),\n        util.get_record_source()\n    );\n\n    RETURN TRUE;\nEND;\n"
      ],
      [
        "revoke_token_enhanced",
        "\nDECLARE\n    v_token_hash BYTEA;\n    v_token_hk BYTEA;\nBEGIN\n    v_token_hash := util.hash_binary(p_token_value);\n    \n    SELECT ath.token_hk INTO v_token_hk\n    FROM auth.api_token_h ath\n    JOIN auth.api_token_s ats ON ath.token_hk = ats.token_hk\n    WHERE ats.token_hash = v_token_hash\n    AND ats.load_end_date IS NULL;\n\n    IF v_token_hk IS NULL THEN\n        RETURN false;\n    END IF;\n\n    UPDATE auth.api_token_s\n    SET load_end_date = util.current_load_date()\n    WHERE token_hk = v_token_hk\n    AND load_end_date IS NULL;\n\n    INSERT INTO auth.api_token_s (\n        token_hk,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        revocation_reason,\n        scope,\n        last_used_at\n    )\n    SELECT \n        token_hk,\n        util.hash_binary(token_hash::text || 'REVOKED' || p_reason),\n        token_hash,\n        token_type,\n        expires_at,\n        true,\n        p_reason,\n        scope,\n        last_used_at\n    FROM auth.api_token_s\n    WHERE token_hk = v_token_hk\n    AND load_end_date = util.current_load_date();\n\n    RETURN true;\nEND;\n"
      ],
      [
        "update_token_usage",
        "\nDECLARE\n    v_api_token_hk BYTEA;\n    v_current_token auth.api_token_s%ROWTYPE;\nBEGIN\n    -- Get current token details\n    SELECT * INTO v_current_token\n    FROM auth.api_token_s\n    WHERE token_hash = p_token_hash\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    IF NOT FOUND THEN\n        RETURN FALSE;\n    END IF;\n\n    v_api_token_hk := v_current_token.api_token_hk;\n\n    -- End current token record\n    UPDATE auth.api_token_s\n    SET load_end_date = util.current_load_date()\n    WHERE api_token_hk = v_api_token_hk\n    AND load_end_date IS NULL;\n\n    -- Create updated token record\n    INSERT INTO auth.api_token_s (\n        api_token_hk,\n        load_date,\n        hash_diff,\n        token_hash,\n        token_type,\n        expires_at,\n        is_revoked,\n        revocation_reason,\n        scope,\n        last_used_at,\n        created_by,\n        revoked_by,\n        revoked_at,\n        record_source\n    ) VALUES (\n        v_api_token_hk,\n        util.current_load_date(),\n        util.hash_binary(v_current_token.token_hash::text || CURRENT_TIMESTAMP::text),\n        v_current_token.token_hash,\n        v_current_token.token_type,\n        v_current_token.expires_at,\n        v_current_token.is_revoked,\n        v_current_token.revocation_reason,\n        v_current_token.scope,\n        CURRENT_TIMESTAMP,\n        v_current_token.created_by,\n        v_current_token.revoked_by,\n        v_current_token.revoked_at,\n        util.get_record_source()\n    );\n\n    RETURN TRUE;\nEND;\n"
      ],
      [
        "validate_ai_access",
        "\nDECLARE\n    v_user_roles TEXT[];\n    v_has_access BOOLEAN := false;\n    v_permissions TEXT[] := '{}';\n    v_data_filters JSONB := '{}';\nBEGIN\n    -- Get user roles (simplified - would need actual role checking)\n    v_user_roles := ARRAY['ai_access', 'horse_owner', 'barn_staff'];\n    \n    -- Check if user has AI access permission\n    IF 'ai_access' = ANY(v_user_roles) THEN\n        v_has_access := true;\n        v_permissions := ARRAY['ai_chat', 'horse_info', 'training_advice'];\n        v_data_filters := '{\"scope\": \"own_horses\", \"sensitive_data\": false}';\n    END IF;\n    \n    -- Staff gets broader access\n    IF 'barn_staff' = ANY(v_user_roles) THEN\n        v_permissions := v_permissions || ARRAY['health_info', 'all_horses'];\n        v_data_filters := '{\"scope\": \"all_horses\", \"sensitive_data\": true}';\n    END IF;\n    \n    RETURN QUERY SELECT v_has_access, v_permissions, v_data_filters;\nEND;\n"
      ],
      [
        "validate_hipaa_policy",
        "\nDECLARE\n    v_messages TEXT[] := ARRAY[]::TEXT[];\n    v_policy auth.security_policy_s%ROWTYPE;\nBEGIN\n    -- Get current policy settings\n    SELECT * INTO v_policy\n    FROM auth.security_policy_s\n    WHERE security_policy_hk = p_policy_hk\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    -- Validate each HIPAA requirement\n    IF v_policy.password_min_length < 12 THEN\n        v_messages := array_append(v_messages, 'Password length must be at least 12 characters for HIPAA compliance');\n    END IF;\n\n    IF NOT v_policy.password_require_special OR \n       NOT v_policy.password_require_number OR \n       NOT v_policy.password_require_uppercase THEN\n        v_messages := array_append(v_messages, 'Password must require special characters, numbers, and uppercase letters');\n    END IF;\n\n    IF v_policy.password_expiry_days > 90 THEN\n        v_messages := array_append(v_messages, 'Passwords must expire within 90 days for HIPAA compliance');\n    END IF;\n\n    IF v_policy.session_timeout_minutes > 15 THEN\n        v_messages := array_append(v_messages, 'Session timeout must not exceed 15 minutes for HIPAA compliance');\n    END IF;\n\n    IF NOT v_policy.require_mfa THEN\n        v_messages := array_append(v_messages, 'Multi-factor authentication must be enabled for HIPAA compliance');\n    END IF;\n\n    IF v_policy.password_history_count < 12 THEN\n        v_messages := array_append(v_messages, 'Password history must remember at least 12 previous passwords');\n    END IF;\n\n    IF v_policy.account_lockout_threshold > 5 THEN\n        v_messages := array_append(v_messages, 'Account lockout threshold should not exceed 5 failed attempts');\n    END IF;\n\n    RETURN QUERY SELECT \n        CASE WHEN array_length(v_messages, 1) IS NULL THEN TRUE ELSE FALSE END,\n        v_messages;\nEND;\n"
      ],
      [
        "validate_password_policy",
        "\nDECLARE\n    v_policy auth.security_policy_s%ROWTYPE;\n    v_violations TEXT[] := ARRAY[]::TEXT[];\n    v_recommendations TEXT[] := ARRAY[]::TEXT[];\n    v_score INTEGER := 100;\nBEGIN\n    -- Get security policy for tenant\n    SELECT sp.* INTO v_policy\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h hp ON sp.security_policy_hk = hp.security_policy_hk\n    WHERE hp.tenant_hk = p_tenant_hk\n    AND sp.is_active = TRUE\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n    \n    -- If no policy found, use defaults\n    IF v_policy.security_policy_hk IS NULL THEN\n        v_policy.password_min_length := 8;\n        v_policy.password_require_uppercase := TRUE;\n        v_policy.password_require_lowercase := TRUE;\n        v_policy.password_require_number := TRUE;\n        v_policy.password_require_special := TRUE;\n    END IF;\n    \n    -- Validate password length\n    IF LENGTH(p_password) < v_policy.password_min_length THEN\n        v_violations := array_append(v_violations, \n            format('Password must be at least %s characters long', v_policy.password_min_length));\n        v_recommendations := array_append(v_recommendations, \n            format('Add %s more characters to meet minimum length requirement', \n                   v_policy.password_min_length - LENGTH(p_password)));\n        v_score := v_score - 30;\n    END IF;\n    \n    -- Validate uppercase requirement\n    IF v_policy.password_require_uppercase AND NOT (p_password ~ '[A-Z]') THEN\n        v_violations := array_append(v_violations, 'Password must contain at least one uppercase letter');\n        v_recommendations := array_append(v_recommendations, 'Add at least one uppercase letter (A-Z)');\n        v_score := v_score - 20;\n    END IF;\n    \n    -- Validate lowercase requirement\n    IF v_policy.password_require_lowercase AND NOT (p_password ~ '[a-z]') THEN\n        v_violations := array_append(v_violations, 'Password must contain at least one lowercase letter');\n        v_recommendations := array_append(v_recommendations, 'Add at least one lowercase letter (a-z)');\n        v_score := v_score - 20;\n    END IF;\n    \n    -- Validate number requirement\n    IF v_policy.password_require_number AND NOT (p_password ~ '[0-9]') THEN\n        v_violations := array_append(v_violations, 'Password must contain at least one number');\n        v_recommendations := array_append(v_recommendations, 'Add at least one number (0-9)');\n        v_score := v_score - 20;\n    END IF;\n    \n    -- Validate special character requirement\n    IF v_policy.password_require_special AND NOT (p_password ~ '[^A-Za-z0-9]') THEN\n        v_violations := array_append(v_violations, 'Password must contain at least one special character');\n        v_recommendations := array_append(v_recommendations, 'Add at least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)');\n        v_score := v_score - 20;\n    END IF;\n    \n    -- Additional strength checks\n    IF LENGTH(p_password) >= 16 THEN\n        v_score := v_score + 10; -- Bonus for long passwords\n    END IF;\n    \n    IF p_password ~ '.*(.)\\1{2,}.*' THEN\n        v_violations := array_append(v_violations, 'Password should not contain repeated characters');\n        v_recommendations := array_append(v_recommendations, 'Avoid using the same character more than twice in a row');\n        v_score := v_score - 10;\n    END IF;\n    \n    -- Ensure score doesn't go below 0\n    v_score := GREATEST(v_score, 0);\n    \n    RETURN QUERY SELECT \n        array_length(v_violations, 1) IS NULL,\n        v_score,\n        v_violations,\n        v_recommendations;\nEND;\n"
      ],
      [
        "validate_session",
        "\nDECLARE\n    v_validation_result RECORD;\nBEGIN\n    -- Initialize outputs\n    p_is_valid := FALSE;\n    p_message := 'Invalid session';\n    p_user_context := NULL;\n\n    -- Call the internal validation function\n    SELECT \n        is_valid, \n        user_hk,\n        session_hk,\n        username,\n        message\n    INTO v_validation_result\n    FROM auth.validate_token_and_session(\n        p_session_token,\n        p_ip_address,\n        p_user_agent\n    );\n    \n    -- Handle invalid session\n    IF NOT COALESCE(v_validation_result.is_valid, FALSE) THEN\n        p_is_valid := FALSE;\n        p_message := COALESCE(v_validation_result.message, 'Session validation failed');\n        RETURN;\n    END IF;\n    \n    -- Get user and tenant context\n    SELECT jsonb_build_object(\n        'user_id', u.user_bk,\n        'tenant_id', t.tenant_bk,\n        'email', uas.username,\n        'first_name', COALESCE(ups.first_name, ''),\n        'last_name', COALESCE(ups.last_name, ''),\n        'roles', COALESCE(\n            (SELECT array_agg(rds.role_name)\n             FROM auth.user_role_l url\n             JOIN auth.role_h r ON url.role_hk = r.role_hk\n             JOIN auth.role_definition_s rds ON r.role_hk = rds.role_hk\n             WHERE url.user_hk = u.user_hk\n             AND rds.load_date = (\n                 SELECT MAX(load_date)\n                 FROM auth.role_definition_s\n                 WHERE role_hk = r.role_hk\n                 AND load_end_date IS NULL\n             )), \n            ARRAY[]::TEXT[]\n        )\n    ) INTO p_user_context\n    FROM auth.user_h u\n    JOIN auth.tenant_h t ON u.tenant_hk = t.tenant_hk\n    JOIN auth.user_auth_s uas ON u.user_hk = uas.user_hk\n    LEFT JOIN auth.user_profile_s ups ON u.user_hk = ups.user_hk\n    WHERE u.user_hk = v_validation_result.user_hk\n    AND uas.load_date = (\n        SELECT MAX(load_date) \n        FROM auth.user_auth_s \n        WHERE user_hk = u.user_hk \n        AND load_end_date IS NULL\n    )\n    AND (ups.load_date IS NULL OR ups.load_date = (\n        SELECT MAX(load_date) \n        FROM auth.user_profile_s \n        WHERE user_hk = u.user_hk \n        AND load_end_date IS NULL\n    ));\n    \n    -- Update session activity\n    UPDATE auth.session_state_s\n    SET last_activity = CURRENT_TIMESTAMP,\n        load_end_date = util.current_load_date()\n    WHERE session_hk = v_validation_result.session_hk\n    AND load_end_date IS NULL;\n    \n    -- Insert new session state record\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    )\n    SELECT \n        session_hk,\n        util.current_load_date(),\n        util.hash_binary(session_bk || 'ACTIVE_UPDATED'),\n        session_start,\n        p_ip_address,\n        p_user_agent,\n        session_data,\n        'ACTIVE',\n        CURRENT_TIMESTAMP,\n        util.get_record_source()\n    FROM auth.session_state_s\n    WHERE session_hk = v_validation_result.session_hk\n    AND load_end_date = util.current_load_date();\n    \n    p_is_valid := TRUE;\n    p_message := 'Session valid';\n\nEXCEPTION WHEN OTHERS THEN\n    p_is_valid := FALSE;\n    p_message := 'Session validation failed';\n    p_user_context := NULL;\nEND;\n"
      ],
      [
        "validate_session_enhanced",
        "\nDECLARE\n    v_session_data RECORD;\n    v_security_policy RECORD;\nBEGIN\n    -- Get session and related data\n    SELECT \n        sss.session_status,\n        sss.session_start,\n        sss.last_activity,\n        sss.ip_address,\n        sss.session_data,\n        usl.user_hk,\n        sh.tenant_hk\n    INTO v_session_data\n    FROM auth.session_state_s sss\n    JOIN auth.session_h sh ON sss.session_hk = sh.session_hk\n    JOIN auth.user_session_l usl ON sh.session_hk = usl.session_hk\n    WHERE sss.session_hk = p_session_hk\n    AND sss.load_end_date IS NULL\n    ORDER BY sss.load_date DESC\n    LIMIT 1;\n\n    -- If no session found\n    IF v_session_data.session_status IS NULL THEN\n        RETURN QUERY SELECT FALSE, 'Session not found', NULL::BYTEA, FALSE, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Get security policy\n    SELECT \n        COALESCE(sp.session_timeout_minutes, 60) as session_timeout_minutes,\n        COALESCE(sp.session_absolute_timeout_hours, 12) as session_absolute_timeout_hours,\n        COALESCE(sp.require_mfa, false) as require_mfa,\n        sp.allowed_ip_ranges\n    INTO v_security_policy\n    FROM auth.security_policy_s sp\n    JOIN auth.security_policy_h sph ON sp.security_policy_hk = sph.security_policy_hk\n    WHERE sph.tenant_hk = v_session_data.tenant_hk\n    AND sp.is_active = TRUE\n    AND sp.load_end_date IS NULL\n    ORDER BY sp.load_date DESC\n    LIMIT 1;\n\n    -- Set defaults if no policy found\n    IF v_security_policy.session_timeout_minutes IS NULL THEN\n        v_security_policy.session_timeout_minutes := 60;\n        v_security_policy.session_absolute_timeout_hours := 12;\n        v_security_policy.require_mfa := false;\n    END IF;\n\n    -- Validate session status\n    IF v_session_data.session_status != 'ACTIVE' THEN\n        RETURN QUERY SELECT FALSE, 'Session is not active', v_session_data.user_hk, \n                           v_security_policy.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Check session timeout\n    IF v_session_data.last_activity < (CURRENT_TIMESTAMP - (v_security_policy.session_timeout_minutes || ' minutes')::interval) THEN\n        RETURN QUERY SELECT FALSE, 'Session has timed out due to inactivity', v_session_data.user_hk, \n                           v_security_policy.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Check absolute session timeout\n    IF v_session_data.session_start < (CURRENT_TIMESTAMP - (v_security_policy.session_absolute_timeout_hours || ' hours')::interval) THEN\n        RETURN QUERY SELECT FALSE, 'Session has exceeded maximum duration', v_session_data.user_hk, \n                           v_security_policy.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Check IP address validation if configured\n    IF v_security_policy.allowed_ip_ranges IS NOT NULL AND array_length(v_security_policy.allowed_ip_ranges, 1) > 0 THEN\n        -- Simple IP validation (can be enhanced for CIDR ranges)\n        IF NOT (p_ip_address::text = ANY(v_security_policy.allowed_ip_ranges)) THEN\n            RETURN QUERY SELECT FALSE, 'IP address not allowed', v_session_data.user_hk, \n                               v_security_policy.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n            RETURN;\n        END IF;\n    END IF;\n\n    -- Update last activity time\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        session_end,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    ) VALUES (\n        p_session_hk,\n        util.current_load_date(),\n        util.hash_binary(p_session_hk::text || 'ACTIVITY_UPDATE' || CURRENT_TIMESTAMP::text),\n        v_session_data.session_start,\n        NULL, -- session_end\n        p_ip_address,\n        p_user_agent,\n        v_session_data.session_data,\n        'ACTIVE',\n        CURRENT_TIMESTAMP, -- last_activity\n        util.get_record_source()\n    );\n\n    -- End-date the previous session state record\n    UPDATE auth.session_state_s\n    SET load_end_date = util.current_load_date()\n    WHERE session_hk = p_session_hk\n    AND load_end_date IS NULL\n    AND load_date < util.current_load_date();\n\n    -- Calculate session expiration time\n    RETURN QUERY SELECT \n        TRUE, \n        'Session is valid', \n        v_session_data.user_hk, \n        v_security_policy.require_mfa,\n        LEAST(\n            v_session_data.last_activity + (v_security_policy.session_timeout_minutes || ' minutes')::interval,\n            v_session_data.session_start + (v_security_policy.session_absolute_timeout_hours || ' hours')::interval\n        );\nEND;\n"
      ],
      [
        "validate_session_json",
        "\nDECLARE\n    v_is_valid BOOLEAN;\n    v_message TEXT;\n    v_user_context JSONB;\n    v_inet_address INET;\nBEGIN\n    -- Handle IP address conversion safely\n    BEGIN\n        v_inet_address := p_ip_address::INET;\n    EXCEPTION WHEN OTHERS THEN\n        v_inet_address := '0.0.0.0'::INET;\n    END;\n\n    -- Call the existing procedure\n    CALL auth.validate_session(\n        p_session_token,\n        v_inet_address,\n        p_user_agent,\n        v_is_valid,\n        v_message,\n        v_user_context\n    );\n    \n    -- Return consolidated JSON response\n    RETURN jsonb_build_object(\n        'valid', v_is_valid,\n        'message', v_message,\n        'userContext', v_user_context,\n        'timestamp', CURRENT_TIMESTAMP\n    );\nEXCEPTION WHEN OTHERS THEN\n    -- Handle unexpected errors gracefully\n    RETURN jsonb_build_object(\n        'valid', FALSE,\n        'message', 'An unexpected error occurred during session validation: ' || SQLERRM,\n        'userContext', NULL,\n        'timestamp', CURRENT_TIMESTAMP,\n        'errorCode', SQLSTATE\n    );\nEND;\n"
      ],
      [
        "validate_session_optimized",
        "\nDECLARE\n    v_session_data RECORD;\n    v_policy_data RECORD;\n    v_start_time TIMESTAMP WITH TIME ZONE;\nBEGIN\n    v_start_time := CURRENT_TIMESTAMP;\n    \n    -- Get session data using optimized index\n    SELECT \n        sss.session_status,\n        sss.session_start,\n        sss.last_activity,\n        usl.user_hk,\n        sh.tenant_hk\n    INTO v_session_data\n    FROM auth.session_state_s sss\n    JOIN auth.session_h sh ON sss.session_hk = sh.session_hk\n    JOIN auth.user_session_l usl ON sh.session_hk = usl.session_hk\n    WHERE sss.session_hk = p_session_hk\n    AND sss.session_status = 'ACTIVE'\n    AND sss.load_end_date IS NULL\n    ORDER BY sss.load_date DESC\n    LIMIT 1;\n\n    -- If no active session found\n    IF v_session_data.session_status IS NULL THEN\n        RETURN QUERY SELECT FALSE, 'Session not found or inactive', NULL::BYTEA, FALSE, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Get policy data from materialized view\n    SELECT \n        mtsp.session_timeout_minutes,\n        mtsp.require_mfa\n    INTO v_policy_data\n    FROM auth.mv_tenant_security_policies mtsp\n    WHERE mtsp.tenant_hk = v_session_data.tenant_hk\n    AND mtsp.rn = 1;\n\n    -- Set defaults if no policy found\n    IF v_policy_data.session_timeout_minutes IS NULL THEN\n        v_policy_data.session_timeout_minutes := 60;\n        v_policy_data.require_mfa := false;\n    END IF;\n\n    -- Check session timeouts (using only available timeout setting)\n    IF v_session_data.last_activity < (CURRENT_TIMESTAMP - (v_policy_data.session_timeout_minutes || ' minutes')::interval) THEN\n        RETURN QUERY SELECT FALSE, 'Session timeout due to inactivity', v_session_data.user_hk, \n                           v_policy_data.require_mfa, NULL::TIMESTAMP WITH TIME ZONE;\n        RETURN;\n    END IF;\n\n    -- Update last activity efficiently\n    INSERT INTO auth.session_state_s (\n        session_hk,\n        load_date,\n        hash_diff,\n        session_start,\n        session_end,\n        ip_address,\n        user_agent,\n        session_data,\n        session_status,\n        last_activity,\n        record_source\n    ) VALUES (\n        p_session_hk,\n        util.current_load_date(),\n        util.hash_binary(p_session_hk::text || 'ACTIVITY_UPDATE' || CURRENT_TIMESTAMP::text),\n        v_session_data.session_start,\n        NULL,\n        p_ip_address,\n        p_user_agent,\n        jsonb_build_object('optimized_validation', true),\n        'ACTIVE',\n        CURRENT_TIMESTAMP,\n        util.get_record_source()\n    );\n\n    -- End-date previous record\n    UPDATE auth.session_state_s\n    SET load_end_date = util.current_load_date()\n    WHERE session_hk = p_session_hk\n    AND load_end_date IS NULL\n    AND load_date < util.current_load_date();\n\n    -- Log performance metrics\n    PERFORM util.analyze_query_performance(\n        'validate_session_optimized',\n        v_session_data.tenant_hk\n    );\n\n    -- Return successful validation\n    RETURN QUERY SELECT \n        TRUE, \n        'Session is valid', \n        v_session_data.user_hk, \n        v_policy_data.require_mfa,\n        v_session_data.last_activity + (v_policy_data.session_timeout_minutes || ' minutes')::interval;\nEND;\n"
      ],
      [
        "validate_token_and_session",
        "\nDECLARE\n    v_token_hash BYTEA;\n    v_api_token_hk BYTEA;\n    v_activity_metadata JSONB;\nBEGIN\n    -- Calculate token hash for lookup\n    v_token_hash := util.hash_binary(p_token_value);\n\n    -- Comprehensive token and session validation\n    RETURN QUERY\n    WITH token_validation AS (\n        SELECT \n            ats.api_token_hk,\n            ats.token_hash,\n            ats.expires_at,\n            ats.is_revoked,\n            stl.session_hk,\n            utl.user_hk,\n            sss.session_start,\n            sss.session_status,\n            COALESCE(sps.session_timeout_minutes, 60) AS session_timeout_minutes,\n            ath.tenant_hk\n        FROM auth.api_token_s ats\n        JOIN auth.api_token_h ath ON ats.api_token_hk = ath.api_token_hk\n        LEFT JOIN auth.session_token_l stl ON ats.api_token_hk = stl.api_token_hk\n        LEFT JOIN auth.user_token_l utl ON ats.api_token_hk = utl.api_token_hk\n        LEFT JOIN auth.session_state_s sss ON stl.session_hk = sss.session_hk AND sss.load_end_date IS NULL\n        LEFT JOIN auth.security_policy_h sph ON ath.tenant_hk = sph.tenant_hk\n        LEFT JOIN auth.security_policy_s sps ON sph.security_policy_hk = sps.security_policy_hk AND sps.load_end_date IS NULL\n        WHERE ats.token_hash = v_token_hash\n        AND ats.load_end_date IS NULL\n        ORDER BY ats.load_date DESC, sss.load_date DESC, sps.load_date DESC\n        LIMIT 1\n    )\n    SELECT \n        CASE \n            WHEN tv.api_token_hk IS NULL THEN FALSE\n            WHEN tv.is_revoked THEN FALSE\n            WHEN tv.expires_at < CURRENT_TIMESTAMP THEN FALSE\n            WHEN tv.session_hk IS NOT NULL AND tv.session_status != 'ACTIVE' THEN FALSE\n            WHEN tv.session_hk IS NOT NULL AND tv.session_start + (tv.session_timeout_minutes || ' minutes')::INTERVAL < CURRENT_TIMESTAMP THEN FALSE\n            ELSE TRUE\n        END,\n        tv.user_hk,\n        tv.session_hk,\n        CASE \n            WHEN tv.api_token_hk IS NULL THEN 'Token not found'\n            WHEN tv.is_revoked THEN 'Token has been revoked'\n            WHEN tv.expires_at < CURRENT_TIMESTAMP THEN 'Token has expired'\n            WHEN tv.session_hk IS NOT NULL AND tv.session_status != 'ACTIVE' THEN 'Associated session is not active'\n            WHEN tv.session_hk IS NOT NULL AND tv.session_start + (tv.session_timeout_minutes || ' minutes')::INTERVAL < CURRENT_TIMESTAMP THEN 'Session has timed out'\n            ELSE 'Token and session are valid'\n        END\n    FROM token_validation tv;\n\n    -- Record token activity for valid tokens\n    SELECT api_token_hk INTO v_api_token_hk\n    FROM auth.api_token_s\n    WHERE token_hash = v_token_hash\n    AND load_end_date IS NULL\n    ORDER BY load_date DESC\n    LIMIT 1;\n\n    IF v_api_token_hk IS NOT NULL THEN\n        -- Prepare activity metadata\n        v_activity_metadata := jsonb_build_object(\n            'endpoint', COALESCE(p_endpoint, 'unknown'),\n            'ip_address', COALESCE(p_ip_address::text, 'unknown'),\n            'user_agent', COALESCE(p_user_agent, 'unknown'),\n            'validation_timestamp', CURRENT_TIMESTAMP\n        );\n\n        -- End previous activity record\n        UPDATE auth.token_activity_s\n        SET load_end_date = util.current_load_date()\n        WHERE api_token_hk = v_api_token_hk\n        AND load_end_date IS NULL;\n\n        -- Create new activity record\n        INSERT INTO auth.token_activity_s (\n            api_token_hk,\n            load_date,\n            hash_diff,\n            last_activity_timestamp,\n            activity_type,\n            endpoint_accessed,\n            ip_address,\n            user_agent,\n            activity_metadata,\n            record_source\n        ) VALUES (\n            v_api_token_hk,\n            util.current_load_date(),\n            util.hash_binary(CURRENT_TIMESTAMP::text || COALESCE(p_endpoint, 'validation')),\n            CURRENT_TIMESTAMP,\n            'VALIDATION',\n            p_endpoint,\n            p_ip_address,\n            p_user_agent,\n            v_activity_metadata,\n            util.get_record_source()\n        );\n    END IF;\nEND;\n"
      ],
      [
        "validate_token_comprehensive",
        "\nDECLARE\n    v_token_hash BYTEA;\n    v_token_hk BYTEA;\n    v_user_agent_hash BYTEA;\n    v_is_compliance_event BOOLEAN := false;\nBEGIN\n    v_token_hash := util.hash_binary(p_token_value);\n    \n    v_user_agent_hash := CASE \n        WHEN p_user_agent IS NOT NULL \n        THEN util.hash_binary(p_user_agent)\n        ELSE NULL \n    END;\n\n    RETURN QUERY\n    WITH token_validation AS (\n        SELECT \n            ats.token_hk,\n            ats.token_hash,\n            ats.is_revoked,\n            ats.expires_at,\n            ats.scope,\n            uth.tenant_hk,\n            uth.user_hk,\n            utl.user_hk as linked_user_hk,\n            stl.session_hk,\n            ups.email as username,\n            sss.session_status,\n            sss.last_activity,\n            CASE \n                WHEN p_ip_address IS NOT NULL AND \n                     EXISTS (\n                         SELECT 1 FROM auth.ip_tracking_s its \n                         WHERE its.ip_address = p_ip_address \n                         AND its.suspicious_activity_flag = true\n                         AND its.load_end_date IS NULL\n                     ) THEN true\n                ELSE false\n            END as compliance_event\n        FROM auth.api_token_s ats\n        JOIN auth.api_token_h ath ON ats.token_hk = ath.token_hk\n        JOIN auth.user_token_l utl ON ath.token_hk = utl.token_hk\n        JOIN auth.user_h uth ON utl.user_hk = uth.user_hk\n        JOIN auth.user_profile_s ups ON uth.user_hk = ups.user_hk AND ups.load_end_date IS NULL\n        LEFT JOIN auth.session_token_l stl ON ath.token_hk = stl.token_hk\n        LEFT JOIN auth.session_state_s sss ON stl.session_hk = sss.session_hk AND sss.load_end_date IS NULL\n        WHERE ats.token_hash = v_token_hash\n        AND ats.load_end_date IS NULL\n        ORDER BY ats.load_date DESC\n        LIMIT 1\n    )\n    SELECT \n        CASE \n            WHEN tv.token_hk IS NULL THEN FALSE\n            WHEN tv.is_revoked THEN FALSE\n            WHEN tv.expires_at < CURRENT_TIMESTAMP THEN FALSE\n            WHEN tv.session_hk IS NOT NULL AND tv.session_status != 'ACTIVE' THEN FALSE\n            WHEN tv.session_hk IS NOT NULL AND tv.last_activity < CURRENT_TIMESTAMP - INTERVAL '20 minutes' THEN FALSE\n            ELSE TRUE\n        END as is_valid,\n        tv.linked_user_hk as user_hk,\n        tv.session_hk,\n        tv.tenant_hk,\n        tv.username,\n        tv.scope as permissions,\n        tv.expires_at,\n        CASE \n            WHEN tv.token_hk IS NULL THEN 'Token not found'\n            WHEN tv.is_revoked THEN 'Token has been revoked'\n            WHEN tv.expires_at < CURRENT_TIMESTAMP THEN 'Token has expired'\n            WHEN tv.session_hk IS NOT NULL AND tv.session_status != 'ACTIVE' THEN 'Associated session is not active'\n            WHEN tv.session_hk IS NOT NULL AND tv.last_activity < CURRENT_TIMESTAMP - INTERVAL '20 minutes' THEN 'Session has timed out'\n            ELSE 'Token is valid and active'\n        END as message,\n        tv.compliance_event as compliance_alert\n    FROM token_validation tv;\n\n    SELECT ath.token_hk INTO v_token_hk\n    FROM auth.api_token_h ath\n    JOIN auth.api_token_s ats ON ath.token_hk = ats.token_hk\n    WHERE ats.token_hash = v_token_hash\n    AND ats.load_end_date IS NULL;\n\n    IF v_token_hk IS NOT NULL THEN\n        INSERT INTO auth.token_activity_s (\n            token_hk,\n            hash_diff,\n            activity_timestamp,\n            activity_type,\n            endpoint_accessed,\n            ip_address,\n            user_agent_hash,\n            compliance_event\n        ) VALUES (\n            v_token_hk,\n            util.hash_binary('VALIDATION_' || CURRENT_TIMESTAMP::text),\n            CURRENT_TIMESTAMP,\n            'TOKEN_VALIDATION',\n            COALESCE(p_endpoint, 'unknown'),\n            p_ip_address,\n            v_user_agent_hash,\n            v_is_compliance_event\n        );\n    END IF;\nEND;\n"
      ],
      [
        "validate_template_readiness",
        "\nBEGIN\n    -- Check if essential schemas exist\n    RETURN QUERY\n    SELECT \n        'Schema: auth'::VARCHAR(100) as check_name,\n        CASE WHEN EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = 'auth') \n             THEN 'PASS'::VARCHAR(20) ELSE 'FAIL'::VARCHAR(20) END as status,\n        'Authentication and authorization schema'::TEXT as details;\n    \n    RETURN QUERY\n    SELECT \n        'Schema: business'::VARCHAR(100) as check_name,\n        CASE WHEN EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = 'business') \n             THEN 'PASS'::VARCHAR(20) ELSE 'FAIL'::VARCHAR(20) END as status,\n        'Business logic and entities schema'::TEXT as details;\n        \n    RETURN QUERY\n    SELECT \n        'Schema: util'::VARCHAR(100) as check_name,\n        CASE WHEN EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = 'util') \n             THEN 'PASS'::VARCHAR(20) ELSE 'FAIL'::VARCHAR(20) END as status,\n        'Utility functions and tools schema'::TEXT as details;\n        \n    RETURN QUERY\n    SELECT \n        'Schema: audit'::VARCHAR(100) as check_name,\n        CASE WHEN EXISTS(SELECT 1 FROM information_schema.schemata WHERE schema_name = 'audit') \n             THEN 'PASS'::VARCHAR(20) ELSE 'FAIL'::VARCHAR(20) END as status,\n        'Audit and compliance tracking schema'::TEXT as details;\n    \n    -- Check if essential functions exist\n    RETURN QUERY\n    SELECT \n        'Function: util.hash_binary'::VARCHAR(100) as check_name,\n        CASE WHEN EXISTS(SELECT 1 FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid \n                        WHERE n.nspname = 'util' AND p.proname = 'hash_binary') \n             THEN 'PASS'::VARCHAR(20) ELSE 'FAIL'::VARCHAR(20) END as status,\n        'Data Vault 2.0 hash key generation'::TEXT as details;\n        \n    RETURN QUERY\n    SELECT \n        'Table: util.deployment_log'::VARCHAR(100) as check_name,\n        CASE WHEN EXISTS(SELECT 1 FROM information_schema.tables \n                        WHERE table_schema = 'util' AND table_name = 'deployment_log') \n             THEN 'PASS'::VARCHAR(20) ELSE 'FAIL'::VARCHAR(20) END as status,\n        'Deployment tracking and audit trail'::TEXT as details;\nEND;\n"
      ]
    ],
    "assessment": {
      "completeness_percentage": 100.0,
      "components_present": 8,
      "total_components": 8,
      "strengths": [
        "User Management",
        "Token System",
        "Session Management",
        "Auth Functions",
        "Api Auth",
        "Security Policies",
        "Performance Indexes",
        "Token Validation"
      ],
      "gaps": [],
      "recommendation": "ROBUST"
    }
  },
  "schemas": [
    {
      "name": "ai_monitoring",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_user=U/postgres,authenticated_users=U/postgres,dv_admin=UC/postgres,admin_access=UC/postgres"
    },
    {
      "name": "api",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_api_user=U/postgres,onevault_readonly=U/postgres,onevault_implementation=UC/postgres,app_user=U/postgres"
    },
    {
      "name": "archive",
      "owner": "postgres",
      "permissions": null
    },
    {
      "name": "audit",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_audit_user=U/postgres,onevault_readonly=U/postgres,onevault_implementation=UC/postgres,=U/postgres,app_user=U/postgres"
    },
    {
      "name": "auth",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_api_user=U/postgres,onevault_readonly=U/postgres,onevault_implementation=UC/postgres,app_user=U/postgres"
    },
    {
      "name": "business",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_business_user=U/postgres,app_api_user=U/postgres,app_user=U/postgres"
    },
    {
      "name": "compliance",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_user=U/postgres,app_api_user=U/postgres"
    },
    {
      "name": "config",
      "owner": "postgres",
      "permissions": null
    },
    {
      "name": "debug",
      "owner": "postgres",
      "permissions": null
    },
    {
      "name": "infomart",
      "owner": "postgres",
      "permissions": null
    },
    {
      "name": "metadata",
      "owner": "postgres",
      "permissions": null
    },
    {
      "name": "public",
      "owner": "pg_database_owner",
      "permissions": "pg_database_owner=UC/pg_database_owner,=U/pg_database_owner,onevault_readonly=U/pg_database_owner,onevault_implementation=UC/pg_database_owner"
    },
    {
      "name": "raw",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_raw_user=U/postgres,app_staging_user=U/postgres,app_api_user=U/postgres,onevault_readonly=U/postgres,onevault_implementation=UC/postgres,app_user=U/postgres"
    },
    {
      "name": "ref",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_api_user=U/postgres,app_user=U/postgres"
    },
    {
      "name": "staging",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_staging_user=U/postgres,onevault_readonly=U/postgres,onevault_implementation=UC/postgres,app_user=U/postgres"
    },
    {
      "name": "util",
      "owner": "postgres",
      "permissions": "postgres=UC/postgres,app_api_user=U/postgres,onevault_readonly=U/postgres,onevault_implementation=UC/postgres,app_user=U/postgres"
    },
    {
      "name": "validation",
      "owner": "postgres",
      "permissions": null
    }
  ],
  "tables": [
    {
      "schema": "ai_monitoring",
      "name": "ai_analysis_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "ai_analysis_results_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "alert_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "alert_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "analysis_alert_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "entity_analysis_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "monitored_entity_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "monitored_entity_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "zt_access_policies_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "zt_access_policies_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "zt_security_events_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "zt_security_events_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "ai_compliance_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "ai_compliance_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "ai_security_event_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "ai_security_event_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "audit_detail_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "audit_event_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "error_log_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "error_log_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "security_event_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "security_event_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "system_health_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "system_health_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "api_token_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "api_token_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "ip_tracking_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "role_definition_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "role_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "security_policy_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "security_policy_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "security_tracking_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "session_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "session_state_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "session_token_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "tenant_definition_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "tenant_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "tenant_profile_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "token_activity_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "user_auth_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "user_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "user_profile_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "user_role_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "user_session_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "user_session_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "user_session_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "user_token_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_alert_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_alert_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_interaction_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_interaction_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_interaction_security_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_observation_alert_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_observation_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_observation_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_session_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_session_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ai_session_interaction_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "asset_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "asset_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "asset_ownership_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "asset_ownership_terms_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "business_entity_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "business_entity_profile_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "business_trip_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "contract_parties_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "entity_relationship_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "entity_relationship_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "intellectual_property_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "ip_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "monitored_entity_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "monitored_entity_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "monitoring_sensor_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "monitoring_sensor_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "note_payable_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "note_payable_terms_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "service_contract_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "service_contract_terms_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "tax_record_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "tax_record_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "trip_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "user_ai_interaction_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "user_ai_observation_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "user_ai_session_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "compliance",
      "name": "consent_audit_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "compliance",
      "name": "patient_consent_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "compliance",
      "name": "patient_consent_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "compliance",
      "name": "patient_user_l",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "metadata",
      "name": "record_source",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "raw",
      "name": "login_attempt_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "raw",
      "name": "login_attempt_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "raw",
      "name": "login_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "raw",
      "name": "user_request_details_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "raw",
      "name": "user_request_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ref",
      "name": "ai_alert_type_r",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ref",
      "name": "ai_context_type_r",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ref",
      "name": "ai_model_r",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ref",
      "name": "ai_observation_type_r",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ref",
      "name": "compliance_framework_r",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ref",
      "name": "entity_type_r",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ref",
      "name": "tax_code_r",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "ref",
      "name": "transaction_type_r",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "staging",
      "name": "login_attempt_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "staging",
      "name": "login_status_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "staging",
      "name": "user_creation_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "staging",
      "name": "user_validation_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "ai_performance_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "ai_performance_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "cache_performance_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "cache_performance_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "database_version",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "deployment_log",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "query_performance_h",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "query_performance_s",
      "type": "BASE TABLE",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "readonly_database_summary",
      "type": "VIEW",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "readonly_function_summary",
      "type": "VIEW",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "template_features",
      "type": "BASE TABLE",
      "owner": "postgres"
    }
  ],
  "functions": [
    {
      "schema": "ai_monitoring",
      "name": "create_alert",
      "arguments": "p_tenant_hk bytea, p_alert_type character varying, p_severity character varying, p_alert_message text, p_analysis_hk bytea DEFAULT NULL::bytea, p_entity_hk bytea DEFAULT NULL::bytea, p_alert_data jsonb DEFAULT NULL::jsonb, p_created_by_user_hk bytea DEFAULT NULL::bytea",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "create_monitored_entity",
      "arguments": "p_tenant_hk bytea, p_entity_bk character varying, p_entity_name character varying, p_entity_type character varying, p_location_info jsonb DEFAULT NULL::jsonb, p_monitoring_config jsonb DEFAULT NULL::jsonb, p_created_by_user_hk bytea DEFAULT NULL::bytea",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "log_security_event",
      "arguments": "p_tenant_hk bytea, p_event_type character varying, p_severity character varying, p_description text, p_source_ip inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_user_hk bytea DEFAULT NULL::bytea, p_event_metadata jsonb DEFAULT NULL::jsonb",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "store_ai_analysis",
      "arguments": "p_tenant_hk bytea, p_entity_hk bytea, p_analysis_type character varying, p_analysis_data jsonb, p_confidence_score numeric DEFAULT NULL::numeric, p_model_version character varying DEFAULT NULL::character varying, p_created_by_user_hk bytea DEFAULT NULL::bytea",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "trigger_security_response",
      "arguments": "p_tenant_hk bytea, p_threat_level character varying, p_response_actions text[], p_user_hk bytea DEFAULT NULL::bytea, p_security_event_hk bytea DEFAULT NULL::bytea",
      "return_type": "boolean",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "ai_monitoring",
      "name": "validate_zero_trust_access",
      "arguments": "p_tenant_hk bytea, p_user_hk bytea DEFAULT NULL::bytea, p_token_value text DEFAULT NULL::text, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_requested_resource character varying DEFAULT NULL::character varying, p_endpoint character varying DEFAULT NULL::character varying",
      "return_type": "TABLE(p_access_granted boolean, p_risk_score integer, p_access_level character varying, p_required_actions text[], p_session_valid boolean, p_user_context jsonb)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "admin_reset_password",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_acknowledge_alert",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_chat_history",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_create_session",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_get_active_alerts",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_get_observation_analytics",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_get_observations",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_log_observation",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_monitoring_acknowledge_alert",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_monitoring_get_alerts",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_monitoring_get_entity_timeline",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_monitoring_ingest",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_monitoring_system_health",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "ai_secure_chat",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "auth_complete_login",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "auth_login",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "auth_login_test",
      "arguments": "p_username text, p_password text",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "auth_logout",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "auth_validate_session",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "change_password",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "consent_create",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "consent_status",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "forgot_password_request",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "security_audit",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "security_policies_get",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "security_rate_limit_check",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "system_health_check",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "tenant_register",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "tenant_roles_list",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "tenants_list",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "test_all_endpoints",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "test_auth_with_roles",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "test_existing_endpoints",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "token_validate",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "tokens_generate",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "tokens_revoke",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "tokens_validate",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "user_register",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "users_profile_get",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "users_profile_update",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "users_register",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "validate_contract",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "validate_fixed_contract",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "api",
      "name": "validate_secure_contract",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "audit_password_storage",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "log_error",
      "arguments": "p_tenant_hk bytea, p_error_code character varying, p_error_message text, p_context_data jsonb DEFAULT NULL::jsonb",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "log_security_event",
      "arguments": "p_tenant_hk bytea, p_event_type character varying, p_event_description text, p_event_metadata jsonb DEFAULT NULL::jsonb",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "log_security_event",
      "arguments": "p_event_type character varying, p_event_severity character varying, p_event_description text, p_source_ip_address inet, p_user_agent text, p_affected_user_hk bytea, p_threat_level character varying, p_event_metadata jsonb DEFAULT NULL::jsonb",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "audit",
      "name": "maintain_audit_tables",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "bulk_expire_sessions",
      "arguments": "p_session_hks bytea[]",
      "return_type": "TABLE(sessions_processed integer, processing_time_ms integer)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "change_password",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "check_account_lockout",
      "arguments": "p_tenant_hk bytea, p_user_hk bytea",
      "return_type": "boolean",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "check_rate_limit_enhanced",
      "arguments": "p_tenant_hk bytea, p_ip_address inet, p_endpoint_path character varying, p_user_agent text DEFAULT NULL::text",
      "return_type": "TABLE(is_allowed boolean, wait_time_seconds integer, reason text, compliance_alert boolean)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "cleanup_expired_sessions",
      "arguments": "",
      "return_type": "TABLE(sessions_expired integer, tokens_revoked integer, cleanup_duration_ms integer)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "create_session_with_token",
      "arguments": "IN p_user_hk bytea, IN p_ip_address inet, IN p_user_agent text, OUT p_session_hk bytea, OUT p_token_value text",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "establish_base_security_policy",
      "arguments": "IN p_tenant_hk bytea, IN p_policy_name character varying",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "generate_api_token",
      "arguments": "p_user_hk bytea, p_token_type character varying, p_scope text[], p_expires_in interval DEFAULT '1 day'::interval",
      "return_type": "TABLE(token_value text, expires_at timestamp with time zone)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "generate_policy_bk",
      "arguments": "p_tenant_hk bytea, p_policy_name character varying",
      "return_type": "character varying",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "generate_security_report",
      "arguments": "IN p_tenant_hk bytea, IN p_start_date timestamp with time zone, IN p_end_date timestamp with time zone",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "generate_session_token",
      "arguments": "",
      "return_type": "text",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "generate_token_for_session",
      "arguments": "IN p_session_hk bytea, INOUT p_token_value text DEFAULT NULL::text",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "get_cached_user_auth",
      "arguments": "p_username character varying, p_tenant_hk bytea",
      "return_type": "TABLE(user_hk bytea, password_hash bytea, password_salt bytea, account_locked boolean, account_locked_until timestamp with time zone, failed_login_attempts integer, last_login_date timestamp with time zone)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "get_tenant_definition",
      "arguments": "p_tenant_hk bytea",
      "return_type": "TABLE(tenant_hk bytea, tenant_name character varying, tenant_display_name character varying, tenant_status character varying, subscription_level character varying, max_users integer, compliance_level character varying, tenant_settings jsonb, feature_flags jsonb)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "get_tenant_security_policy",
      "arguments": "p_tenant_hk bytea",
      "return_type": "TABLE(security_policy_hk bytea, policy_name character varying, password_min_length integer, session_timeout_minutes integer, require_mfa boolean, is_hipaa_compliant boolean)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "get_user_salt",
      "arguments": "p_email character varying, p_tenant_hk bytea",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "login_user",
      "arguments": "IN p_username character varying, IN p_password text, IN p_ip_address inet, IN p_user_agent text, OUT p_success boolean, OUT p_message text, OUT p_tenant_list jsonb, OUT p_session_token text, OUT p_user_data jsonb, IN p_auto_login boolean DEFAULT true",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "maintain_security_state",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "monitor_failed_logins",
      "arguments": "p_tenant_hk bytea, p_time_window interval DEFAULT '01:00:00'::interval",
      "return_type": "TABLE(suspicious_ips inet[], failed_attempts_count integer, unique_usernames_targeted integer, threat_assessment character varying)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "process_failed_login",
      "arguments": "p_tenant_hk bytea, p_username character varying, p_failure_reason character varying, p_ip_address inet",
      "return_type": "boolean",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "process_valid_login",
      "arguments": "IN p_login_attempt_hk bytea, OUT p_session_hk bytea, OUT p_user_hk bytea",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "process_valid_login_enhanced",
      "arguments": "IN p_login_attempt_hk bytea, OUT p_session_hk bytea, OUT p_user_hk bytea",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "register_tenant",
      "arguments": "IN p_tenant_name character varying, IN p_admin_email character varying, IN p_admin_password text, IN p_admin_first_name character varying, IN p_admin_last_name character varying, OUT p_tenant_hk bytea, OUT p_admin_user_hk bytea",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "register_user",
      "arguments": "IN p_tenant_hk bytea, IN p_email character varying, IN p_password text, IN p_first_name character varying, IN p_last_name character varying, IN p_role_bk character varying, OUT p_user_hk bytea",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "reset_password",
      "arguments": "p_request jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "revoke_token",
      "arguments": "p_token_hash bytea, p_reason text DEFAULT 'Administrative revocation'::text",
      "return_type": "boolean",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "revoke_token_enhanced",
      "arguments": "p_token_value text, p_reason text DEFAULT 'Manual revocation'::text, p_revoked_by_user_hk bytea DEFAULT NULL::bytea",
      "return_type": "boolean",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "rollback_step_13",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "update_security_policy",
      "arguments": "IN p_policy_hk bytea, IN p_updates jsonb",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "update_tenant_definition",
      "arguments": "p_tenant_hk bytea, p_tenant_name character varying DEFAULT NULL::character varying, p_tenant_display_name character varying DEFAULT NULL::character varying, p_tenant_status character varying DEFAULT NULL::character varying, p_subscription_level character varying DEFAULT NULL::character varying, p_max_users integer DEFAULT NULL::integer, p_compliance_level character varying DEFAULT NULL::character varying, p_tenant_settings jsonb DEFAULT NULL::jsonb, p_feature_flags jsonb DEFAULT NULL::jsonb",
      "return_type": "boolean",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "update_token_usage",
      "arguments": "p_token_hash bytea",
      "return_type": "boolean",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "update_user_password_direct",
      "arguments": "p_tenant_hk bytea, p_username character varying, p_new_password text, p_force_change boolean DEFAULT true",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "validate_ai_access",
      "arguments": "p_user_bk character varying, p_tenant_bk character varying, p_requested_feature character varying",
      "return_type": "TABLE(p_has_access boolean, p_permissions text[], p_data_filters jsonb)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "validate_hipaa_policy",
      "arguments": "p_policy_hk bytea",
      "return_type": "TABLE(is_compliant boolean, validation_messages text[])",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "validate_password_policy",
      "arguments": "p_tenant_hk bytea, p_password text",
      "return_type": "TABLE(is_valid boolean, validation_score integer, policy_violations text[], recommendations text[])",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "validate_session",
      "arguments": "IN p_session_token text, IN p_ip_address inet, IN p_user_agent text, OUT p_is_valid boolean, OUT p_message text, OUT p_user_context jsonb",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "validate_session_enhanced",
      "arguments": "p_session_hk bytea, p_ip_address inet, p_user_agent text",
      "return_type": "TABLE(is_valid boolean, validation_message text, user_hk bytea, requires_mfa boolean, session_expires_at timestamp with time zone)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "validate_session_json",
      "arguments": "p_session_token text, p_ip_address text, p_user_agent text",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "validate_session_optimized",
      "arguments": "p_session_hk bytea, p_ip_address inet, p_user_agent text",
      "return_type": "TABLE(is_valid boolean, validation_message text, user_hk bytea, requires_mfa boolean, session_expires_at timestamp with time zone)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "validate_token_and_session",
      "arguments": "p_token_value text, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_endpoint character varying DEFAULT NULL::character varying",
      "return_type": "TABLE(is_valid boolean, user_hk bytea, session_hk bytea, message text)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "validate_token_comprehensive",
      "arguments": "p_token_value text, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_endpoint character varying DEFAULT NULL::character varying",
      "return_type": "TABLE(is_valid boolean, user_hk bytea, session_hk bytea, tenant_hk bytea, username character varying, permissions text[], expires_at timestamp with time zone, message text, compliance_alert boolean)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "auth",
      "name": "verify_step_13_implementation",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "analyze_content_safety",
      "arguments": "p_content text, p_context_type character varying DEFAULT 'general'::character varying",
      "return_type": "TABLE(safety_level character varying)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "create_ai_session",
      "arguments": "p_session_bk character varying, p_user_bk character varying, p_tenant_bk character varying, p_session_purpose character varying DEFAULT 'general_chat'::character varying",
      "return_type": "TABLE(p_success boolean, p_session_hk bytea, p_message text)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "create_business_entity",
      "arguments": "p_tenant_hk bytea, p_entity_bk character varying, p_entity_name character varying, p_entity_type character varying, p_tax_id character varying, p_formation_date date, p_state_of_formation character varying, p_business_address jsonb, p_business_purpose text",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "get_ai_interaction_history",
      "arguments": "p_user_bk character varying, p_tenant_bk character varying, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0, p_context_type character varying DEFAULT NULL::character varying, p_start_date timestamp with time zone DEFAULT NULL::timestamp with time zone, p_end_date timestamp with time zone DEFAULT NULL::timestamp with time zone",
      "return_type": "TABLE(interaction_id character varying, question_text text, response_text text, context_type character varying, model_used character varying, interaction_timestamp timestamp with time zone, processing_time_ms integer, security_level character varying)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "store_ai_interaction",
      "arguments": "p_interaction_bk character varying, p_user_bk character varying, p_tenant_bk character varying, p_question_text text, p_response_text text, p_model_used character varying, p_session_bk character varying DEFAULT NULL::character varying, p_context_type character varying DEFAULT 'general'::character varying, p_processing_time_ms integer DEFAULT NULL::integer, p_token_count_input integer DEFAULT NULL::integer, p_token_count_output integer DEFAULT NULL::integer, p_security_level character varying DEFAULT 'safe'::character varying, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text",
      "return_type": "TABLE(p_success boolean, p_interaction_hk bytea, p_message text)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "transfer_asset_ownership",
      "arguments": "p_tenant_hk bytea, p_asset_hk bytea, p_new_owner_entity_hk bytea, p_transfer_date date, p_transfer_method character varying, p_lease_back_rate numeric, p_market_validation jsonb",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "business",
      "name": "validate_market_rates",
      "arguments": "p_service_type character varying, p_proposed_rate numeric, p_comparable_data jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "compliance",
      "name": "check_consent_status",
      "arguments": "p_tenant_hk bytea, p_patient_identifier character varying, p_consent_type character varying DEFAULT NULL::character varying",
      "return_type": "TABLE(consent_hk bytea, consent_type character varying, consent_given boolean, consent_date timestamp with time zone, withdrawal_date timestamp with time zone, is_active boolean, requires_renewal boolean, renewal_date date, data_categories text[], sharing_permissions jsonb)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "compliance",
      "name": "create_patient_consent",
      "arguments": "p_tenant_hk bytea, p_patient_identifier character varying, p_consent_type character varying, p_consent_category character varying DEFAULT 'GENERAL'::character varying, p_consent_given boolean DEFAULT true, p_consent_method character varying DEFAULT 'WRITTEN'::character varying, p_consent_scope text DEFAULT 'Standard healthcare operations'::text, p_data_categories text[] DEFAULT ARRAY['DEMOGRAPHIC'::text, 'MEDICAL'::text], p_sharing_permissions jsonb DEFAULT '{}'::jsonb, p_user_hk bytea DEFAULT NULL::bytea",
      "return_type": "TABLE(consent_hk bytea, consent_bk character varying, success boolean, message text)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "debug",
      "name": "check_user_auth_records",
      "arguments": "p_username text",
      "return_type": "TABLE(user_hk text, username text, load_date timestamp with time zone, load_end_date timestamp with time zone, is_current boolean, failed_attempts integer, account_locked boolean, last_login_date timestamp with time zone)",
      "language": "sql",
      "owner": "postgres"
    },
    {
      "schema": "metadata",
      "name": "upsert_record_source",
      "arguments": "IN p_record_source_code character varying, IN p_record_source_name character varying, IN p_description text",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "armor",
      "arguments": "bytea",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "armor",
      "arguments": "bytea, text[], text[]",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "crypt",
      "arguments": "text, text",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "dearmor",
      "arguments": "text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "decrypt",
      "arguments": "bytea, bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "decrypt_iv",
      "arguments": "bytea, bytea, bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "digest",
      "arguments": "text, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "digest",
      "arguments": "bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "encrypt",
      "arguments": "bytea, bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "encrypt_iv",
      "arguments": "bytea, bytea, bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "gen_random_bytes",
      "arguments": "integer",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "gen_random_uuid",
      "arguments": "",
      "return_type": "uuid",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "gen_salt",
      "arguments": "text, integer",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "gen_salt",
      "arguments": "text",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "hmac",
      "arguments": "text, text, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "hmac",
      "arguments": "bytea, bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_armor_headers",
      "arguments": "text, OUT key text, OUT value text",
      "return_type": "SETOF record",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_key_id",
      "arguments": "bytea",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_decrypt",
      "arguments": "bytea, bytea",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_decrypt",
      "arguments": "bytea, bytea, text",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_decrypt",
      "arguments": "bytea, bytea, text, text",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_decrypt_bytea",
      "arguments": "bytea, bytea, text, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_decrypt_bytea",
      "arguments": "bytea, bytea",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_decrypt_bytea",
      "arguments": "bytea, bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_encrypt",
      "arguments": "text, bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_encrypt",
      "arguments": "text, bytea",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_encrypt_bytea",
      "arguments": "bytea, bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_pub_encrypt_bytea",
      "arguments": "bytea, bytea",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_sym_decrypt",
      "arguments": "bytea, text",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_sym_decrypt",
      "arguments": "bytea, text, text",
      "return_type": "text",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_sym_decrypt_bytea",
      "arguments": "bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_sym_decrypt_bytea",
      "arguments": "bytea, text, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_sym_encrypt",
      "arguments": "text, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_sym_encrypt",
      "arguments": "text, text, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_sym_encrypt_bytea",
      "arguments": "bytea, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "public",
      "name": "pgp_sym_encrypt_bytea",
      "arguments": "bytea, text, text",
      "return_type": "bytea",
      "language": "c",
      "owner": "postgres"
    },
    {
      "schema": "raw",
      "name": "capture_login_attempt",
      "arguments": "p_tenant_hk bytea, p_username character varying, p_ip_address inet, p_user_agent text",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "raw",
      "name": "create_user_request",
      "arguments": "IN p_tenant_hk bytea, IN p_email character varying, IN p_password text, IN p_first_name character varying, IN p_last_name character varying, IN p_ip_address inet, IN p_user_agent text, OUT request_hk bytea, IN p_raw_request_data jsonb DEFAULT NULL::jsonb",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "raw",
      "name": "trf_process_user_request",
      "arguments": "",
      "return_type": "trigger",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "staging",
      "name": "process_raw_login_attempt",
      "arguments": "p_login_attempt_hk bytea",
      "return_type": "boolean",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "staging",
      "name": "trf_process_validated_user",
      "arguments": "",
      "return_type": "trigger",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "staging",
      "name": "validate_login_credentials",
      "arguments": "p_login_attempt_hk bytea",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "staging",
      "name": "validate_user_creation",
      "arguments": "IN p_user_request_hk bytea",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "analyze_field_length_usage",
      "arguments": "p_schema_name text DEFAULT 'auth'::text, p_column_pattern text DEFAULT '%username%'::text",
      "return_type": "TABLE(schema_name text, table_name text, column_name text, data_type text, max_length integer, actual_max_length integer, utilization_percentage numeric, recommendation text)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "analyze_query_performance",
      "arguments": "p_query_type text, p_tenant_hk bytea",
      "return_type": "bytea",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "audit_track_bridge",
      "arguments": "",
      "return_type": "trigger",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "audit_track_default",
      "arguments": "",
      "return_type": "trigger",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "audit_track_dispatcher",
      "arguments": "",
      "return_type": "trigger",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "audit_track_hub",
      "arguments": "",
      "return_type": "trigger",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "audit_track_link",
      "arguments": "",
      "return_type": "trigger",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "audit_track_reference",
      "arguments": "",
      "return_type": "trigger",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "audit_track_satellite",
      "arguments": "",
      "return_type": "trigger",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "check_system_health",
      "arguments": "",
      "return_type": "TABLE(health_status character varying, overall_score numeric, component_scores jsonb, warnings text[], critical_issues text[])",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "create_audit_triggers",
      "arguments": "p_schema_name text",
      "return_type": "void",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "create_audit_triggers_safe",
      "arguments": "p_schema_name text",
      "return_type": "void",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "current_load_date",
      "arguments": "",
      "return_type": "timestamp with time zone",
      "language": "sql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "final_security_report",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "generate_bk",
      "arguments": "input_text text",
      "return_type": "character varying",
      "language": "sql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "generate_performance_report",
      "arguments": "p_tenant_hk bytea DEFAULT NULL::bytea, p_hours_back integer DEFAULT 24",
      "return_type": "TABLE(metric_category character varying, metric_name character varying, current_value numeric, threshold_value numeric, health_status character varying, trend_direction character varying, recommendations text[])",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "generate_security_report",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "get_connection_info",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "get_record_source",
      "arguments": "",
      "return_type": "character varying",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "hash_binary",
      "arguments": "input text",
      "return_type": "bytea",
      "language": "sql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "hash_concat",
      "arguments": "VARIADIC args text[]",
      "return_type": "bytea",
      "language": "sql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "log_audit_event",
      "arguments": "p_event_type text, p_resource_type text, p_resource_id text, p_actor text, p_event_details jsonb DEFAULT '{}'::jsonb",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "log_deployment_complete",
      "arguments": "p_deployment_id integer, p_success boolean DEFAULT true, p_final_notes text DEFAULT NULL::text",
      "return_type": "boolean",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "log_deployment_start",
      "arguments": "p_deployment_name character varying, p_deployment_notes text DEFAULT NULL::text, p_rollback_script text DEFAULT NULL::text",
      "return_type": "integer",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "optimize_table_statistics",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "process_hex_tenant",
      "arguments": "hex_string text",
      "return_type": "bytea",
      "language": "sql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "refresh_performance_caches",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "rollback_step_14",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "rollback_step_15",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "rollback_step_16",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "rollback_step_21",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "schedule_performance_maintenance",
      "arguments": "",
      "return_type": "text",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "simulate_connection_test",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "test_api_security",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "test_api_security_final",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "test_record_source",
      "arguments": "",
      "return_type": "text",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "test_registration",
      "arguments": "",
      "return_type": "text",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "test_role_permissions",
      "arguments": "",
      "return_type": "jsonb",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "validate_template_readiness",
      "arguments": "",
      "return_type": "TABLE(check_name character varying, status character varying, details text)",
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "verify_step_14_implementation",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "verify_step_15_implementation",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    },
    {
      "schema": "util",
      "name": "verify_step_16_implementation",
      "arguments": "",
      "return_type": null,
      "language": "plpgsql",
      "owner": "postgres"
    }
  ],
  "users_roles": [
    {
      "name": "admin_access",
      "can_login": false,
      "is_superuser": true,
      "can_create_db": true,
      "can_create_role": true,
      "member_of": []
    },
    {
      "name": "admin_staff",
      "can_login": false,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": [
        "health_staff"
      ]
    },
    {
      "name": "app_api_user",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "app_audit_user",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "app_business_user",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "app_raw_user",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "app_staging_user",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "app_user",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "authenticated_users",
      "can_login": false,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "barn_user",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "dashboard_readonly",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "dv_admin",
      "can_login": false,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "dv_developer",
      "can_login": false,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "dv_loader",
      "can_login": false,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "dv_reader",
      "can_login": false,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "health_staff",
      "can_login": false,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": [
        "authenticated_users"
      ]
    },
    {
      "name": "onevault_implementation",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "onevault_readonly",
      "can_login": true,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "postgres",
      "can_login": true,
      "is_superuser": true,
      "can_create_db": true,
      "can_create_role": true,
      "member_of": []
    },
    {
      "name": "read_access",
      "can_login": false,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    },
    {
      "name": "test",
      "can_login": true,
      "is_superuser": true,
      "can_create_db": true,
      "can_create_role": true,
      "member_of": []
    },
    {
      "name": "write_access",
      "can_login": false,
      "is_superuser": false,
      "can_create_db": false,
      "can_create_role": false,
      "member_of": []
    }
  ],
  "tenant_structure": {
    "tenant_tables": [
      [
        "tenant_definition_s",
        "BASE TABLE"
      ],
      [
        "tenant_h",
        "BASE TABLE"
      ],
      [
        "tenant_profile_s",
        "BASE TABLE"
      ]
    ],
    "tenant_profile_columns": [
      [
        "tenant_hk",
        "bytea",
        "NO",
        null,
        null
      ],
      [
        "load_date",
        "timestamp with time zone",
        "NO",
        "util.current_load_date()",
        null
      ],
      [
        "load_end_date",
        "timestamp with time zone",
        "YES",
        null,
        null
      ],
      [
        "hash_diff",
        "bytea",
        "NO",
        null,
        null
      ],
      [
        "tenant_name",
        "character varying",
        "NO",
        null,
        100
      ],
      [
        "tenant_description",
        "character varying",
        "YES",
        null,
        500
      ],
      [
        "domain_name",
        "character varying",
        "YES",
        null,
        255
      ],
      [
        "is_active",
        "boolean",
        "YES",
        "true",
        null
      ],
      [
        "subscription_level",
        "character varying",
        "YES",
        "'standard'::character varying",
        50
      ],
      [
        "subscription_start_date",
        "timestamp with time zone",
        "YES",
        null,
        null
      ],
      [
        "subscription_end_date",
        "timestamp with time zone",
        "YES",
        null,
        null
      ],
      [
        "contact_email",
        "character varying",
        "YES",
        null,
        255
      ],
      [
        "contact_phone",
        "character varying",
        "YES",
        null,
        50
      ],
      [
        "max_users",
        "integer",
        "YES",
        "10",
        null
      ],
      [
        "record_source",
        "character varying",
        "NO",
        null,
        100
      ],
      [
        "created_date",
        "timestamp with time zone",
        "YES",
        "util.current_load_date()",
        null
      ],
      [
        "last_updated_date",
        "timestamp with time zone",
        "YES",
        "util.current_load_date()",
        null
      ]
    ],
    "tenant_definition_columns": [
      [
        "tenant_hk",
        "bytea",
        "NO",
        null,
        null
      ],
      [
        "load_date",
        "timestamp with time zone",
        "NO",
        "util.current_load_date()",
        null
      ],
      [
        "load_end_date",
        "timestamp with time zone",
        "YES",
        null,
        null
      ],
      [
        "hash_diff",
        "bytea",
        "NO",
        null,
        null
      ],
      [
        "record_source",
        "character varying",
        "NO",
        "util.get_record_source()",
        100
      ],
      [
        "tenant_name",
        "character varying",
        "NO",
        null,
        200
      ],
      [
        "tenant_display_name",
        "character varying",
        "YES",
        null,
        200
      ],
      [
        "tenant_description",
        "text",
        "YES",
        null,
        null
      ],
      [
        "tenant_status",
        "character varying",
        "NO",
        "'ACTIVE'::character varying",
        50
      ],
      [
        "contact_email",
        "character varying",
        "YES",
        null,
        255
      ],
      [
        "contact_phone",
        "character varying",
        "YES",
        null,
        50
      ],
      [
        "contact_address",
        "jsonb",
        "YES",
        null,
        null
      ],
      [
        "subscription_level",
        "character varying",
        "YES",
        "'STANDARD'::character varying",
        50
      ],
      [
        "subscription_start_date",
        "timestamp with time zone",
        "YES",
        null,
        null
      ],
      [
        "subscription_end_date",
        "timestamp with time zone",
        "YES",
        null,
        null
      ],
      [
        "max_users",
        "integer",
        "YES",
        "100",
        null
      ],
      [
        "max_storage_gb",
        "integer",
        "YES",
        "10",
        null
      ],
      [
        "tenant_settings",
        "jsonb",
        "YES",
        "'{}'::jsonb",
        null
      ],
      [
        "feature_flags",
        "jsonb",
        "YES",
        "'{}'::jsonb",
        null
      ],
      [
        "compliance_level",
        "character varying",
        "YES",
        "'STANDARD'::character varying",
        50
      ],
      [
        "data_retention_days",
        "integer",
        "YES",
        "2555",
        null
      ],
      [
        "encryption_required",
        "boolean",
        "YES",
        "true",
        null
      ],
      [
        "created_by",
        "character varying",
        "YES",
        "SESSION_USER",
        100
      ],
      [
        "last_updated_by",
        "character varying",
        "YES",
        "SESSION_USER",
        100
      ],
      [
        "last_updated_date",
        "timestamp with time zone",
        "YES",
        "CURRENT_TIMESTAMP",
        null
      ]
    ]
  },
  "user_profile_columns": [
    [
      "user_hk",
      "bytea",
      "NO",
      null,
      null
    ],
    [
      "load_date",
      "timestamp with time zone",
      "NO",
      "util.current_load_date()",
      null
    ],
    [
      "load_end_date",
      "timestamp with time zone",
      "YES",
      null,
      null
    ],
    [
      "hash_diff",
      "bytea",
      "NO",
      null,
      null
    ],
    [
      "first_name",
      "character varying",
      "YES",
      null,
      100
    ],
    [
      "last_name",
      "character varying",
      "YES",
      null,
      100
    ],
    [
      "email",
      "character varying",
      "NO",
      null,
      255
    ],
    [
      "phone",
      "character varying",
      "YES",
      null,
      50
    ],
    [
      "job_title",
      "character varying",
      "YES",
      null,
      100
    ],
    [
      "department",
      "character varying",
      "YES",
      null,
      100
    ],
    [
      "is_active",
      "boolean",
      "YES",
      "true",
      null
    ],
    [
      "created_date",
      "timestamp with time zone",
      "YES",
      "util.current_load_date()",
      null
    ],
    [
      "last_updated_date",
      "timestamp with time zone",
      "YES",
      "util.current_load_date()",
      null
    ],
    [
      "record_source",
      "character varying",
      "NO",
      null,
      100
    ]
  ],
  "ai_system_status": [
    [
      "AI Observation Tables",
      6,
      10,
      "PARTIAL"
    ],
    [
      "AI Reference Data",
      4,
      2,
      "COMPLETE"
    ],
    [
      "AI API Functions",
      13,
      5,
      "COMPLETE"
    ]
  ],
  "investigation_metadata": {
    "timestamp": "2025-06-13T17:41:14.132834",
    "database": "one_vault",
    "host": "localhost",
    "investigator_version": "2.0",
    "features_investigated": [
      "domain_contamination",
      "authentication_system",
      "tenant_structure",
      "ai_monitoring_readiness"
    ]
  },
  "recommendations": {
    "authentication_integration": [
      "\ud83d\udd10 Authentication System: ROBUST (100.0% complete)",
      "\u2705 ROBUST auth system - integrate AI monitoring with existing token validation",
      "\u2705 Use existing session management for AI monitoring authentication",
      "\u2705 Leverage existing security policies for tenant isolation"
    ],
    "ai_monitoring_integration": [
      "\u2705 Found 14 API auth functions - integrate AI endpoints with existing API auth",
      "\u2705 Use existing API authentication patterns for ai_monitoring_* endpoints",
      "\u2705 Existing token system found - integrate AI monitoring with current token validation",
      "\ud83d\udd27 Modify validate_zero_trust_access() to use existing token validation patterns"
    ],
    "general_notes": [
      "Database has 17 schemas",
      "Database has 117 tables",
      "Database has 193 functions"
    ]
  }
}